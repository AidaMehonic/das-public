<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>Molecular Diversity Preservation International (MDPI)</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">23202174</article-id><article-id pub-id-type="pmc">3522927</article-id><article-id pub-id-type="doi">10.3390/s121114537</article-id><article-id pub-id-type="publisher-id">sensors-12-14537</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>A Robust Static Decoupling Algorithm for 3-Axis Force Sensors Based on Coupling Error Model and <italic>&#x003b5;</italic>-SVR</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Ma</surname><given-names>Junqing</given-names></name><xref ref-type="aff" rid="af1-sensors-12-14537"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Song</surname><given-names>Aiguo</given-names></name><xref ref-type="aff" rid="af1-sensors-12-14537"><sup>1</sup></xref><xref ref-type="corresp" rid="c1-sensors-12-14537"><sup>*</sup></xref></contrib><contrib contrib-type="author"><name><surname>Xiao</surname><given-names>Jing</given-names></name><xref ref-type="aff" rid="af2-sensors-12-14537"><sup>2</sup></xref></contrib></contrib-group><aff id="af1-sensors-12-14537"><label>1</label> Jiangsu Key Lab of Remote Measurement and Control, School of Instrument Science and Engineering, Southeast University, Nanjing 210096, China; E-Mail: <email>mjqseu@gmail.com</email></aff><aff id="af2-sensors-12-14537"><label>2</label> IMI Lab, Department of Computer Science, The University of North Carolina at Charlotte, Charlotte, NC 28223, USA; E-Mail: <email>xiao@uncc.edu</email></aff><author-notes><corresp id="c1-sensors-12-14537"><label>*</label> Author to whom correspondence should be addressed; E-Mail: <email>a.g.song@seu.edu.cn</email>; Tel.: +86-25-8379-3293; Fax: +86-25-8379-2813.</corresp></author-notes><pub-date pub-type="collection"><year>2012</year></pub-date><pub-date pub-type="epub"><day>29</day><month>10</month><year>2012</year></pub-date><volume>12</volume><issue>11</issue><fpage>14537</fpage><lpage>14555</lpage><history><date date-type="received"><day>14</day><month>8</month><year>2012</year></date><date date-type="rev-recd"><day>22</day><month>10</month><year>2012</year></date><date date-type="accepted"><day>22</day><month>10</month><year>2012</year></date></history><permissions><copyright-statement>&#x000a9; 2012 by the authors; licensee MDPI, Basel, Switzerland.</copyright-statement><copyright-year>2012</copyright-year><license><license-p><!--CREATIVE COMMONS-->This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>).</license-p></license></permissions><abstract><p>Coupling errors are major threats to the accuracy of 3-axis force sensors. Design of decoupling algorithms is a challenging topic due to the uncertainty of coupling errors. The conventional nonlinear decoupling algorithms by a standard Neural Network (NN) are sometimes unstable due to overfitting. In order to avoid overfitting and minimize the negative effect of random noises and gross errors in calibration data, we propose a novel nonlinear static decoupling algorithm based on the establishment of a coupling error model. Instead of regarding the whole system as a black box in conventional algorithm, the coupling error model is designed by the principle of coupling errors, in which the nonlinear relationships between forces and coupling errors in each dimension are calculated separately. Six separate Support Vector Regressions (SVRs) are employed for their ability to perform adaptive, nonlinear data fitting. The decoupling performance of the proposed algorithm is compared with the conventional method by utilizing obtained data from the static calibration experiment of a 3-axis force sensor. Experimental results show that the proposed decoupling algorithm gives more robust performance with high efficiency and decoupling accuracy, and can thus be potentially applied to the decoupling application of 3-axis force sensors.</p></abstract><kwd-group><kwd>force sensors</kwd><kwd>coupling errors</kwd><kwd>decoupling</kwd><kwd>support vector regression (SVR)</kwd></kwd-group></article-meta></front><body><sec><label>1.</label><title>Introduction</title><p>Force sensing is crucial for on-line perception and feedback in interactions between intelligent robotic manipulators and environments. Multi-axis force sensors are used to perceive generalized force information and convert input force signals to voltage signals [<xref ref-type="bibr" rid="b1-sensors-12-14537">1</xref>]. They are usually mounted on the tips of robot arms for automatic contact recognition, motion planning, and force control tasks [<xref ref-type="bibr" rid="b2-sensors-12-14537">2</xref>&#x02013;<xref ref-type="bibr" rid="b4-sensors-12-14537">4</xref>]. Force sensors are widely used in assembly robots, polishing robots, rehabilitation robots, <italic>etc.</italic> [<xref ref-type="bibr" rid="b5-sensors-12-14537">5</xref>&#x02013;<xref ref-type="bibr" rid="b7-sensors-12-14537">7</xref>].</p><p>The accuracy of multi-axis force sensors has a great impact on force-perception based tasks with high precision requirements. This motivates the need to improve measurement precision. For a multi-axis force sensor, a key issue is that input force in one dimension may affect not only output of this dimension but also those of the other dimensions. Errors caused in this way, called the <italic>coupling errors</italic>, are major threats to the accuracy of multi-axis force sensors. Coupling errors occur for various reasons, such as mechanical structures, limitation of machining accuracy, transverse effect of strain gauges, <italic>etc.</italic> Song <italic>et al.</italic> in [<xref ref-type="bibr" rid="b8-sensors-12-14537">8</xref>] developed a self-decoupled 4-axis force/torque sensor to reduce coupling errors by improving hardware design. However, in most cases, it is costly and sometimes infeasible to avoid coupling errors by improving the hardware design and machining accuracy. Decoupling algorithms are always used to reduce coupling errors.</p><p>The common static decoupling algorithm calculates the pseudo-inverse matrix of calibration data based on the Least Square Method (LSM) [<xref ref-type="bibr" rid="b9-sensors-12-14537">9</xref>&#x02013;<xref ref-type="bibr" rid="b11-sensors-12-14537">11</xref>]. This algorithm is based on the assumption that relationships between input forces and output voltages in all dimensions are linear. Afterwards, the transfer matrix between input forces and output voltages are calculated. The obtained transfer matrix is called <italic>calibration matrix</italic>. Voyles <italic>et al.</italic> in [<xref ref-type="bibr" rid="b12-sensors-12-14537">12</xref>] proposed a fast linear decoupling technique called <italic>shape from motion</italic> in which the motion of the force vector and the calibration matrix are simultaneously extracted by singular value decomposition from raw sensor signals. Cao <italic>et al.</italic> in [<xref ref-type="bibr" rid="b13-sensors-12-14537">13</xref>] explored a linear static decoupling method using an NN to increase the accuracy of decoupling. However, large amounts of experiment data indicate the nonlinearity in relationships between forces and coupling errors. Thus, the precision of linear decoupling algorithms is limited and unsatisfactory. Other approaches [<xref ref-type="bibr" rid="b14-sensors-12-14537">14</xref>,<xref ref-type="bibr" rid="b15-sensors-12-14537">15</xref>] employed a feed-forward NN with back propagation (BP) training algorithms to realize the nonlinear Multiple Input Multiple Output (MIMO) mapping of a multi-axis force sensor. In [<xref ref-type="bibr" rid="b15-sensors-12-14537">15</xref>], the authors also used a standard radial basis function (RBF) NN for decoupling. Engineering applications show that decoupling algorithms with a standard NN model can sometimes reduce coupling error significantly, but sometimes generate worse results than without decoupling due to overfitting.</p><p>Support Vector Machine (SVM) is a powerful candidate for decoupling algorithms due to its ability to perform adaptive and nonlinear data fitting. SVM starts from solving problems of classification. With the introduction of Vapnik's <italic>&#x003b5;</italic>-insensitive loss function, it also extends to be a regression prediction tool that uses machine learning theory to maximize predictive accuracy while not subject to local minimal and overfitting [<xref ref-type="bibr" rid="b16-sensors-12-14537">16</xref>]. Support Vector Machine for regression, called <italic>Support Vector Regression</italic>, gradually becomes a powerful tool for nonlinear correcting and compensation in the field of sensors. Guo <italic>et al.</italic> in [<xref ref-type="bibr" rid="b17-sensors-12-14537">17</xref>] established a model based on SVR to correct the nonlinear error of photoelectric displacement sensor. Wang in [<xref ref-type="bibr" rid="b18-sensors-12-14537">18</xref>] used SVR to make nonlinear estimation and temperature compensation of capacitor pressure sensors.</p><p>The design of decoupling algorithms of 3-axis force sensors presents several challenges. First, a 3-axis force sensor is usually used in on-line force perception tasks. This requires the sensor to show quick response to variations of input forces. Thus, the decoupling algorithms should have high time efficiency. Second, inevitable noises in calibration data may result in overfitting such that decoupling precision will be reduced. Also, due to improper operations of laboratory technicians or environment disturbances, occasionally there may be gross errors in calibration data. Gross errors are outliers that strongly deviate from the majority of experiment data. Gross errors may result in unexpected decoupling results such that decoupling precision will be reduced. A reliable decoupling algorithm should be designed to minimize the negative effects of noises and gross errors. Third, because the hardware causes of coupling errors such as the mechanical structures and the limitations of machining accuracy are complex and uncertain, it is difficult to model the coupling errors by polynomials. Thus, a decoupling algorithm should have a high generalization ability.</p><p>Motivated by the above challenges, this paper proposes a precise and fast decoupling algorithm with high reliability. Instead of referring to the whole sensor system as a black box using one standard NN [<xref ref-type="bibr" rid="b14-sensors-12-14537">14</xref>,<xref ref-type="bibr" rid="b15-sensors-12-14537">15</xref>], the proposed decoupling algorithm is designed using the principle of coupling errors, in which the relationships between each input and output are mapped separately in the proposed coupling error model to make the algorithm more reliable. The proposed coupling error model consists of six SVRs and three linear fitting functions, which is more conformable to calibration data structure. Our method is compared with the standard NN method, as they are applied to the same data from a calibration experiment, and our method gives better reliability and higher efficiency.</p><p>The remainder of the paper is organized as follows. Section 2 introduces a novel model of coupling error and its notations. <italic>&#x003b5;</italic>-SVR is described as the nonlinear approximation tool of the model. A decoupling process based on the model is proposed. Section 3 briefly describes the principle of a 3-axis sensor designed in our lab, the calibration experiment process and the structure of the calibration data. Section 4 discusses the implementation details of the decoupling method using a set of experimental data obtained from a calibration experiment. In order to demonstrate that our decoupling algorithm is robust to gross errors, gross errors were artificially introduced into the calibration data and the decoupling accuracy with the gross errors were calculated. Finally, in Section 5 some conclusions are provided.</p></sec><sec><label>2.</label><title>Nonlinear Static Decoupling</title><sec><label>2.1.</label><title>Coupling Error Model and Notations</title><p>We first establish an appropriate coupling error model to capture the relationships between input forces and corresponding coupling errors. In the model, the input forces and output voltages of a 3-axis force sensor in X, Y, Z directions are defined as <italic>f<sub>x</sub></italic>, <italic>f<sub>y</sub></italic>, <italic>f<sub>z</sub></italic> and <italic>u<sub>x</sub></italic>, <italic>u<sub>y</sub></italic>, <italic>u<sub>z</sub></italic>, respectively.</p><p>For each dimension, output voltages are partitioned into two categories. One category includes the voltages corresponding to input forces in the same dimension, called <italic>prime voltages</italic>. The other category includes the voltages corresponding to the input forces in the other two dimensions, called <italic>coupling errors</italic>. We use <italic>u<sub>xx</sub></italic>, <italic>u<sub>yy</sub></italic>, <italic>u<sub>zz</sub></italic> to denote prime voltages and <italic>e<sub>x</sub></italic>, <italic>e<sub>y</sub></italic>, <italic>e<sub>z</sub></italic> to denote coupling errors in X, Y, Z directions, respectively. Prime voltages account for the majority of output voltages. Next, coupling errors are separated into two <italic>coupling error elements</italic> caused by input forces of different dimensions. Let (<italic>e<sub>xy</sub></italic>, <italic>e<sub>xz</sub></italic>) represent the coupling error element in X direction, where <italic>e<sub>xy</sub></italic> refers to the coupling error element caused by <italic>f<sub>y</sub></italic>, and <italic>e<sub>xz</sub></italic> refers to the coupling error element caused by <italic>f<sub>z</sub></italic>. Similarly, we split the coupling error in Y direction into <italic>e<sub>yx</sub></italic> and <italic>e<sub>yz</sub></italic>, and split the coupling error in Z direction into <italic>e<sub>zx</sub></italic> and <italic>e<sub>zy</sub></italic>. We can get:
<disp-formula id="FD1"><label>(1)</label><mml:math id="mm1"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Based on the observation of calibration data of multi-axis force sensors in our lab, we make the following assumptions about coupling errors.</p><list list-type="order"><list-item><p>The relationship between the prime force and the prime voltage in every dimension is linear;</p></list-item><list-item><p>Relationships between disturbing force and their corresponding coupling error elements in every dimension are nonlinear;</p></list-item><list-item><p>The above relationships are independent and time-invariant.</p></list-item></list><p>From the above assumptions and the principle of superposition for stress, we propose a coupling error model as shown in <xref ref-type="fig" rid="f1-sensors-12-14537">Figure 1</xref>.</p><p>In <xref ref-type="fig" rid="f1-sensors-12-14537">Figure 1</xref>, there are three layers in the coupling error model: the input layer, the output layer, and the middle layer. Nine nodes in the middle layer are parallel and separated from each other. Functions <italic>&#x003c9;<sub>x</sub></italic>(), <italic>&#x003c9;<sub>y</sub></italic>() and <italic>&#x003c9;<sub>z</sub></italic>(), are <italic>non-coupling functions</italic>, linearly relating prime force to prime voltage in each dimension as shown in <xref rid="FD2" ref-type="disp-formula">Equation (2)</xref>.</p><disp-formula id="FD2"><label>(2)</label><mml:math id="mm2"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula><p>In calibration experiments, only one-dimensional force is applied to a 3-axis force sensor each time, while the output voltages of all directions are recorded simultaneously. Detailed calibration experiment process will be described in Section 3. Consequently, as for calibration data, no coupling error exists in the output voltage corresponding to the direction of the input force and no prime force exists in the output voltages of other directions. In other words, the output voltage equals the prime voltage when the direction of the output voltage is the same as the direction of the input force, and the output voltage equals the corresponding coupling error elements when the direction of the output voltage is different from the direction of the input force. For instance, during calibration experiment of X direction, a set of standard <italic>f<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> are applied to the force sensor while <italic>f<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> and <italic>f<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> remain zero (the subscript <italic>c</italic> represents &#x0201c;calibration data&#x0201d;). Thus we can get <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>u<sub>xx</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>yx</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>zx</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>. Similarly, for calibration data in Y direction, <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>xy</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>u<sub>yy</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>zy</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>; for calibration data in Z direction, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>xz</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>e<sub>yz</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> = <italic>u<sub>zz</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>.Thus, coefficients <italic>k<sub>xx</sub></italic>, <italic>k<sub>yy</sub></italic>, and <italic>k<sub>zz</sub></italic> in <xref rid="FD2" ref-type="disp-formula">Equation (2)</xref> can be calculated by linear fitting of prime forces and prime voltages of calibration data using LSM.</p><p>Functions respecting nonlinear relationships between disturbing forces and corresponding coupling error elements in every dimension are <italic>&#x003c6;<sub>yx</sub></italic>(), <italic>&#x003c6;<sub>zx</sub></italic>(), <italic>&#x003c6;<sub>xy</sub></italic>(), <italic>&#x003c6;<sub>zy</sub></italic>(), <italic>&#x003c6;<sub>xz</sub></italic>(), <italic>&#x003c6;<sub>yz</sub></italic>(), called <italic>coupling functions</italic> as shown in <xref rid="FD3" ref-type="disp-formula">Equation (3)</xref>.</p><disp-formula id="FD3"><label>(3)</label><mml:math id="mm3"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula><p>Then, <italic>corrected coupling functions &#x003c7;</italic>() can be obtained from <xref rid="FD2" ref-type="disp-formula">Equations (2)</xref> and <xref rid="FD3" ref-type="disp-formula">(3)</xref>:
<disp-formula id="FD4"><label>(4)</label><mml:math id="mm4"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>During a decoupling process of an actual force perception task, one can hardly obtain the exact value of prime voltages <italic>u<sub>xx</sub></italic>, <italic>u<sub>yy</sub></italic>, <italic>u<sub>zz</sub></italic> for <xref rid="FD4" ref-type="disp-formula">Equation (4)</xref>, because the data obtained in a force perception task (called <italic>task data</italic>) are different from calibration data. The input forces in all directions are always non-zero, so the output voltages in all directions contain coupling errors and the output voltages no longer equal the prime voltages. However, a large number of experiment data show that, in most cases, coupling errors take up less than 5% of the full scale (F.S.) output voltages and the absolute values of the slopes of the corrected coupling functions are no more than 0.05. Thus, the output voltages of task data <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub> approximately equal the prime voltages <italic>u<sub>xx</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>yy</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>zz</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub> (the subscript <italic>t</italic> represents &#x0201c;task data&#x0201d;), and can be used as substitutions of the prime voltages <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub> as independent variables of <xref rid="FD4" ref-type="disp-formula">Equation (4)</xref>. This approximate substitution may induce second-order coupling errors. Take <italic>e<sub>yx</sub></italic> for example: the measured coupling error element <italic>e<sub>yx</sub></italic><sub>(</sub><italic><sub>m</sub></italic><sub>)</sub> = <italic>&#x003c7;<sub>yx</sub></italic>(<italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>) is calculated instead of the actual coupling error element <italic>e<sub>yx</sub></italic><sub>(</sub><italic><sub>a</sub></italic><sub>)</sub> = <italic>&#x003c7;<sub>yx</sub></italic>(<italic>u<sub>xx</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>)(the subscript <italic>m</italic> represents &#x0201c;measured&#x0201d;; the subscript <italic>a</italic> represents &#x0201c;actual&#x0201d;). The second-order coupling error <italic>E<sub>e<sub>yx</sub></sub></italic> can be expressed in <xref rid="FD5" ref-type="disp-formula">Equation (5)</xref>,
<disp-formula id="FD5"><label>(5)</label><mml:math id="mm5"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>F.S.</sub></italic><sub>)</sub> represents the full scale value of output voltages in X direction.</p><p>According to the Lagrange mean value theorem, &#x02203;<italic>&#x003be;</italic> &#x02208; (<italic>u<sub>xx</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>) such that
<disp-formula id="FD6"><label>(6)</label><mml:math id="mm6"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msubsup><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>&#x02264;</mml:mo><mml:mfrac><mml:mrow><mml:mn>0.05</mml:mn><mml:mo>&#x022c5;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>%</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></disp-formula></p><p>As a result, the rate of second-order coupling errors is less than 0.25% and can be neglected in most industrial applications.</p><p>We choose <italic>&#x003b5;</italic>-SVR for nonlinear approximations for the corrected coupling functions, which is much less likely to subject to overfitting problems. Also, the fitting processes of those functions are independent from one dimension to another, hence the fitting result of one dimension does not affect that of another dimensions.</p></sec><sec><label>2.2.</label><title>Approximation of Corrected Coupling Functions Using <italic>&#x003b5;</italic>-SVR</title><p>Six <italic>&#x003b5;</italic>-SVRs are utilized to approximate six corrected coupling functions for its generalization ability. <italic>&#x003b5;</italic>-SVR learns the relationship between the input (<italic>i.e.</italic>, prime voltages) and the output (<italic>i.e.</italic>, corresponding coupling error elements) by adjusting the structure and parameters of a flexible model directly from training data to minimize the prediction error.</p><p>The basic idea for the case of nonlinear regression by <italic>&#x003b5;</italic>-SVR is to project the input space <italic>x<sub>i</sub></italic> to a higher dimensional feature space by a map &#x003a6;. Then, the <italic>&#x003b5;</italic>-SVR defines a linear prediction model over the mapped samples in the feature space. A nonlinear function is learned by this model while the capacity of the model is controlled by a parameter that does not depend on the dimensionality of the space [<xref ref-type="bibr" rid="b16-sensors-12-14537">16</xref>]. As calculation with the map &#x003a6; can easily become computationally infeasible (because it is too complex), a kernel function <italic>k</italic> is introduced as the dot product of &#x003a6;, as expressed in <xref rid="FD7" ref-type="disp-formula">Equation (7)</xref>.</p><disp-formula id="FD7"><label>(7)</label><mml:math id="mm7"><mml:mrow><mml:mo>&#x0003c;</mml:mo><mml:mo>&#x003a6;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x003a6;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x0003e;</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula><p>Typical kernels include the linear 
<inline-formula><mml:math id="mm8"><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, the polynomial 
<inline-formula><mml:math id="mm9"><mml:mrow><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>d</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, and the Gaussian Function(RBF) <italic>k</italic>(<italic>x<sub>i</sub></italic>, <italic>x<sub>j</sub></italic>) = exp(&#x02212;&#x02016;<italic>x<sub>i</sub></italic> &#x02212; <italic>x<sub>j</sub></italic>&#x02016;<sup>2</sup>/2<italic>&#x003b4;</italic><sup>2</sup>). The RBF kernel is most frequently used and it is also the one used in our implementation.</p><p>Briefly, the <italic>&#x003b5;</italic>-SVR is to solve a convex optimization problem:
<disp-formula id="FD8"><label>(8a)</label><mml:math id="mm10"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>minimize</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>&#x02016;</mml:mo><mml:mi>w</mml:mi><mml:mo>&#x02016;</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>C</mml:mi><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD9"><label>(8b)</label><mml:math id="mm11"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>subject</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>to</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>w</mml:mi><mml:mo>&#x003a6;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mi>b</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>&#x0025b;</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>w</mml:mi><mml:mo>&#x003a6;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02264;</mml:mo><mml:mi>&#x0025b;</mml:mi><mml:mo>+</mml:mo><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>where <italic>i</italic> = 1,2, &#x02026; , <italic>Q</italic> are training data points, the parameter <italic>w</italic> indicates the flatness of regression function <italic>f</italic> due to the fact that kernels can be associated with flatness properties via regularization operators [<xref ref-type="bibr" rid="b19-sensors-12-14537">19</xref>]. <italic>&#x003be;<sub>i</sub></italic>, 
<inline-formula><mml:math id="mm12"><mml:mrow><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are slack variables introduced by Vapnik's <italic>&#x003b5;</italic>-insensitive loss function [<xref ref-type="bibr" rid="b20-sensors-12-14537">20</xref>], in which errors up to <italic>&#x003b5;</italic> are not penalized, and all further deviations will incur a linear penalization [<xref ref-type="bibr" rid="b21-sensors-12-14537">21</xref>]. <italic>C</italic> &#x0003e; 0 is the regularization parameter determining the trade-off between the flatness of regression function <italic>f</italic>
<inline-formula><mml:math id="mm13"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>&#x02016;</mml:mo><mml:mi>w</mml:mi><mml:mo>&#x02016;</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the total tolerance on deviations larger than <italic>&#x003b5;</italic>
<inline-formula><mml:math id="mm14"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A graphical description of <italic>&#x003b5;</italic>-SVR model is shown in <xref ref-type="fig" rid="f2-sensors-12-14537">Figure 2</xref>. Points on the boundaries and outside the boundaries are called <italic>Support Vectors</italic>.</p><p>To solve the optimization problem of <xref rid="FD8" ref-type="disp-formula">Equation (8)</xref>, a Lagrange function is constructed by introducing Lagrange multipliers <italic>a<sub>i</sub></italic> and
<inline-formula><mml:math id="mm15"><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. Partial derivatives of the Lagrange function with respect to the primal variables (<italic>w</italic>, <italic>b</italic>, <italic>&#x003be;<sub>i</sub></italic>, 
<inline-formula><mml:math id="mm16"><mml:mrow><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>) are calculated. Finally, the dual optimization problem can be derived by partial derivation of the Lagrange function and taking into account that 
<inline-formula><mml:math id="mm17"><mml:mrow><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>:
<disp-formula id="FD10"><label>(9a)</label><mml:math id="mm18"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>maximize</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>j</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x003b5;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02217;</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD11"><label>(9b)</label><mml:math id="mm19"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>subject</mml:mtext><mml:mspace width="0.2em"/><mml:mtext>to</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>and</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo>&#x003b5;</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Note that Support Vectors correspond to training data whose Lagrange multipliers <italic>a<sub>i</sub></italic>'s are non-zero in <xref rid="FD9" ref-type="disp-formula">Equation (9)</xref>. Training data for which <italic>a<sub>i</sub></italic> = <italic>C</italic> are called Bounded Support Vectors, and they are located on the two boundaries in <xref ref-type="fig" rid="f2-sensors-12-14537">Figure 2</xref>. Training data with 0 &#x0003c; <italic>a<sub>i</sub></italic> &#x0003c; <italic>C</italic> are called Free Support Vectors and they are outside the boundaries [<xref ref-type="bibr" rid="b22-sensors-12-14537">22</xref>]. Only Support Vectors contribute to the penalization in <xref rid="FD8" ref-type="disp-formula">Equation (8a)</xref>. <xref rid="FD9" ref-type="disp-formula">Equation (9)</xref> can be solved by optimization algorithms such as Sequential Minimal Optimal, Chunking and Decomposing. The Sequential Minimal Optimal [<xref ref-type="bibr" rid="b23-sensors-12-14537">23</xref>] is most frequently used due to its fast calculation speed. Solving the quadratic problems of <xref rid="FD9" ref-type="disp-formula">Equation (9)</xref> yields the final solution of <italic>&#x003b5;</italic>-SVR:
<disp-formula id="FD12"><label>(10)</label><mml:math id="mm20"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>Q</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mo>&#x02217;</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>It is shown that <italic>&#x003b5;</italic>-SVR has properties of robustness to noises and gross errors even though the gross errors are part of the set of Support Vectors [<xref ref-type="bibr" rid="b24-sensors-12-14537">24</xref>,<xref ref-type="bibr" rid="b25-sensors-12-14537">25</xref>]. This is because the Lagrange Multipliers solved in the objective function of <xref rid="FD9" ref-type="disp-formula">Equation (9)</xref> are upper bounded by the constraint of <xref rid="FD9" ref-type="disp-formula">Equation (9)</xref>. All Support Vectors, including the gross errors, will have Lagrange Multipliers with absolute value no more than the upper bound <italic>C</italic>. From aspect of <xref rid="FD8" ref-type="disp-formula">Equation (8)</xref>, as <italic>C</italic> searches for trade-off between flatness and empirical risk, if necessary, <italic>&#x003b5;</italic>-SVR will sacrifice the tolerance to get a good flatness. <italic>&#x003b5;</italic>-SVR also has many other advantages such as global minima and reduced likelihood of overfitting.</p></sec><sec><label>2.3.</label><title>Decoupling Process</title><p>The whole decoupling process consists of two stages. The first stage is for establishment of the coupling error functions. The second stage is in an actual on-line force perception task. During the task, the output voltages of all directions are obtained and the coupling error model is utilized to eliminate coupling errors and calculate measured forces. Our decoupling process is described as follows:
<list list-type="order"><list-item><p>Conduct the static calibration experiment of a 3-axis force sensor and get the calibration data, which contain sets of input forces and output voltages (<italic>f<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>f<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>f<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> and <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub>).</p></list-item><list-item><p>Do linear fitting of <italic>f<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> and <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> from calibration data in X direction using LSM, to get the slope <italic>k<sub>xx</sub></italic> in <xref rid="FD2" ref-type="disp-formula">Equation (2)</xref>. In the same way, get coefficients <italic>k<sub>yy</sub></italic> and <italic>k<sub>zz</sub></italic> in <xref rid="FD2" ref-type="disp-formula">Equation (2)</xref> from the calibration data in Y direction and Z direction respectively. In this way, three non-coupling functions <italic>&#x003c9;<sub>x</sub></italic>(),<italic>&#x003c9;<sub>y</sub></italic>() and <italic>&#x003c9;<sub>z</sub></italic>() and three inverse functions of the non-coupling functions 
<inline-formula><mml:math id="mm21"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, 
<inline-formula><mml:math id="mm22"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and 
<inline-formula><mml:math id="mm23"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are obtained.</p></list-item><list-item><p>Do nonlinear function approximation for <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> and <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> from the calibration data in X direction by <italic>&#x003b5;</italic>-SVR to get the corrected coupling function <italic>&#x003c7;<sub>yx</sub></italic>(), do nonlinear function approximation for <italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> and <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>c</sub></italic><sub>)</sub> from the calibration data in X direction by <italic>&#x003b5;</italic>-SVR to get the corrected coupling function <italic>&#x003c7;<sub>zx</sub></italic>().</p></list-item><list-item><p>Calculate the corrected coupling functions <italic>&#x003c7;<sub>xy</sub></italic>() and <italic>&#x003c7;<sub>zy</sub></italic>() from calibration data in Y direction and <italic>&#x003c7;<sub>xz</sub></italic>() and <italic>&#x003c7;<sub>yz</sub></italic>() from calibration data in Z direction respectively in the same way as in step 3.</p></list-item></list></p><p>The above steps establish the entire coupling error model. The following steps are designed for decoupling based on the model using a 3-axis force sensor in an actual force perception task.</p><list list-type="roman-upper"><list-item><p>Obtain task data, namely, a set of output voltages (<italic>u<sub>x</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>y</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>, <italic>u<sub>z</sub></italic><sub>(</sub><italic><sub>t</sub></italic><sub>)</sub>) of a 3-axis force sensor, during an actual force perception task. Compute each coupling error elements of measured data using the corrected coupling functions.</p></list-item><list-item><p>Subtract the coupling errors from the output voltages to get prime voltages as shown in <xref rid="FD1" ref-type="disp-formula">Equation (1)</xref>. Then calculate prime forces of measured data, namely, the measured three dimensional forces by 
<inline-formula><mml:math id="mm24"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, 
<inline-formula><mml:math id="mm25"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and 
<inline-formula><mml:math id="mm26"><mml:mrow><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The measured forces <italic>f<sub>x</sub></italic><sub>(</sub><italic><sub>m</sub></italic><sub>)</sub>,<italic>f<sub>y</sub></italic><sub>(</sub><italic><sub>m</sub></italic><sub>)</sub>,<italic>f<sub>z</sub></italic><sub>(</sub><italic><sub>m</sub></italic><sub>)</sub> can also be expressed in <xref rid="FD11" ref-type="disp-formula">Equation (11)</xref>.
<disp-formula id="FD13"><label>(11)</label><mml:math id="mm27"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">xy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">yz</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>w</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zx</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c7;</mml:mi><mml:mrow><mml:mtext mathvariant="italic">zy</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p></list-item></list><p><xref ref-type="fig" rid="f3-sensors-12-14537">Figure 3</xref> shows the flow chart of the whole decoupling process. The blue arrows indicate off-line process of the establishment of the coupling error model with calibration data. The red arrows indicate on-line process of decoupling in an actual force perception task. Note that the coupling error model and decoupling process are proposed with respect to a predefined frame based on the structural characteristics of the sensor. During an actual force perception task, if the orientation of the predefined frame is different from that of the reference frame used for force perception, the measured forces after decoupling with respect to the predefined frame should be transformed by a rotation matrix in order to align with the reference frame.</p></sec></sec><sec><label>3.</label><title>Calibration Experiment</title><p>As an example 3-axis force sensor, we consider a 3-axis force sensor designed and fabricated in our lab. The force measurement range in both X direction and Y direction is &#x02212;100 N to +100 N, and the force measurement range in Z direction is &#x02212;150 N to 0 N. The corresponding output voltages range in X direction and Y direction is &#x02212;1.4 V to +1.4 V, and the output voltages range in Z direction is &#x02212;1.2 V to +1.2 V.</p><p>The key component of the 3-axis force sensor is composed of a cross-beam elastic body with strain gauges, Wheatstone bridges, and a sampling circuit [<xref ref-type="bibr" rid="b26-sensors-12-14537">26</xref>]. The principle of the 3-axis force sensor can be briefly described as follows: under the effect of loading forces, the cross-beam elastic body begins to deform measurably. Strain gauges that are pasted firmly on the surface of the cross-beam elastic body can sense the strains and transform them to changes in resistance. Resistance changes of strain gauges are measured by Wheatstone bridges and transformed to voltages. Finally, the sampling circuit amplifies the output voltages of Wheatstone bridges and transmits the amplified voltage signals to the robot controller.</p><p>The common calibration method for medium range multi-axis force sensors [<xref ref-type="bibr" rid="b27-sensors-12-14537">27</xref>&#x02013;<xref ref-type="bibr" rid="b30-sensors-12-14537">30</xref>] are utilized. A series of standard input forces in three directions are loaded on the sensor separately, and output voltages in all three directions are recorded simultaneously. The diagram of the static calibration experiment setup is shown in <xref ref-type="fig" rid="f4-sensors-12-14537">Figure 4</xref>, which consists of a loading plate, a calibration shaft, a 3-axis force sensor, an indexing plate, a pulley block, weights and a base.</p><p>The force sensor is fixed on a horizontally rotatable indexing plate with scale to ensure the direction of loading forces. The maximum error of the weights is &#x000b1;5 mg. Loading forces in X direction and Y direction are generated by pulley block and weights while indexing plate is rotated by laboratory technicians to ensure the loading direction. During force loading process in Z direction, a series of standard weights are put directly on the loading plate. All loading forces are transferred from weights to force sensors through the calibration shaft. The experiment platform of static calibration experiment is shown in <xref ref-type="fig" rid="f5-sensors-12-14537">Figure 5</xref>.</p><p>The calibration range is from &#x02212;100 N to +100 N with an increment step of 10 N in X direction and Y direction. The calibration range in Z direction is from &#x02212;150 N to 0 N with an increment step of 5 N. The whole calibration experiment is carefully repeated six times. Six sets of calibration data are obtained and zero-corrected. No gross errors are tested in the zero-corrected data.</p></sec><sec sec-type="results"><label>4.</label><title>Results</title><sec><label>4.1.</label><title>Decoupling by a Standard RBF</title><p>Cross validation is used to estimate the performance of decoupling by a standard MIMO RBF NN. The cross validation is repeated three times while each two sets of the zero-corrected calibration, named as &#x0201c;test data I&#x0201d; and &#x0201c;test data II&#x0201d;, are used for verification and the other four sets are used as training data. Matlab Neural Network Toolbox is used for simulations. The variance is set to 1, the maximum MSE error tolerance is set to 2.4 &#x000d7; 10<sup>&#x02212;6</sup>.</p><p>The maximum MSE error tolerance is chosen to be small enough to ensure that all training data be selected as centers of the MIMO RBF NN.</p><p>In order to test the decoupling accuracy, interference errors <italic>&#x003b3;</italic> are calculated. Taking calibration data in X direction for example, the interference error <italic>&#x003b3;<sub>x</sub></italic> is calculated in <xref rid="FD12" ref-type="disp-formula">Equation (12)</xref>,
<disp-formula id="FD14"><label>(12)</label><mml:math id="mm28"><mml:mrow><mml:msub><mml:mi>&#x003b3;</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>max</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mo>max</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <italic>f<sub>x</sub></italic><sub>(</sub><italic><sub>FS</sub></italic><sub>)</sub> denotes the full scale value of loaded force in X direction. The interference error <italic>&#x003b3;<sub>x</sub></italic> accounts for maximum coupling errors in Y direction and Z direction induced by loaded force in X direction. <italic>&#x003b3;<sub>y</sub></italic> and <italic>&#x003b3;<sub>z</sub></italic> are calculated in the same way. Interference errors of initial data and data after decoupling by a standard MIMO RBF NN are shown in <xref ref-type="table" rid="t1-sensors-12-14537">Table 1</xref>.</p><p><xref ref-type="table" rid="t1-sensors-12-14537">Table 1</xref> shows that the decoupling algorithm by a standard MIMO RBF is unreliable, because although some interference errors are reduced to less than 1%, some interference errors are even worse than initial data (in boldface). This is because compared with the number of training data, there are too many parameters in the MIMO RBF NN. Also, different coupling error elements are not well related. For example, there is little relationship between <italic>e<sub>xy</sub></italic> and <italic>e<sub>xz</sub></italic>. However, decoupling by a standard MIMO RBF NN means all the relationships are regarded as the same in the training process. The standard MIMO RBF NN does not have a good conformability with the calibration data shape. As a result, random noise in the training data may easily contribute to overfitting.</p></sec><sec><label>4.2.</label><title>Decoupling by the Coupling Error Model and <italic>&#x003b5;</italic>-SVR</title><p>We also use cross validation to test the performance of our proposed decoupling algorithm. Here we take the first round of cross validation for example. To quantify the strong linearity of non-coupling functions, linear fittings are performed on the training data (plotted as blue points) to determine the slopes and strength of the correlations (plotted as black lines) as shown in <xref ref-type="fig" rid="f6-sensors-12-14537">Figure 6</xref>.</p><p>The linear correlation coefficients for all three directions are calculated to be more than 0.99, which correspond to assumption 1 (see Section 2). The inverse functions of non-coupling functions are obtained as:
<disp-formula id="FD15"><label>(13)</label><mml:math id="mm29"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>75.065</mml:mn><mml:msub><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>77.788</mml:mn><mml:msub><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>z</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>125.17</mml:mn><mml:msub><mml:mi>u</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The six corrected coupling functions are approximated by <italic>&#x003b5;</italic>-SVRs. Each corrected coupling function is fitted by a separate <italic>&#x003b5;</italic>-SVR, where the pre-specified parameters are set as the same value. The <italic>&#x003b5;</italic>-SVR based approximations of corrected coupling functions are carried out using MATLAB and LIBSVM [<xref ref-type="bibr" rid="b31-sensors-12-14537">31</xref>] software applications. LIBSVM [<xref ref-type="bibr" rid="b31-sensors-12-14537">31</xref>] is an integrated software for support vector classification, distribution estimation and regression. It implements an SMO-type optimization algorithm [<xref ref-type="bibr" rid="b32-sensors-12-14537">32</xref>] and provides an efficient interface for MATLAB. The initial parameters used to train the <italic>&#x003b5;</italic>-SVR model by LIBSVM tool are listed in <xref ref-type="table" rid="t2-sensors-12-14537">Table 2</xref>.</p><p>Here we also employ six separate Single Input Single Output(SISO) RBF NNs to do nonlinear approximations of the corrected coupling error functions to make a comparison with <italic>&#x003b5;</italic>-SVRs. Parameters of the SISO RBF NNs are defined the same as the MIMO RBF NN, which is mentioned in Section 4.1.</p><p><xref ref-type="fig" rid="f7-sensors-12-14537">Figure 7</xref> shows the fitting results of the six corrected coupling functions.The blue points represent training data, the red points and magenta points represent two groups of test data respectively, the black curves represent fitted corrected coupling functions using <italic>&#x003b5;</italic>-SVR and the red curves represent fitted corrected coupling functions using SISO RBF NN. Relationships between disturbing forces and related coupling error elements are nonlinear and distinct from one another, which correspond to assumption 2 and assumption 3 (see Section 2.1). In <xref ref-type="fig" rid="f7-sensors-12-14537">Figures 7(a)</xref> and <xref ref-type="fig" rid="f7-sensors-12-14537">7(d)</xref>, obvious overfittings happen in the fitting results of <italic>&#x003c7;<sub>xy</sub></italic> and <italic>&#x003c7;<sub>yz</sub></italic> using SISO RBF NNs, but the <italic>&#x003b5;</italic>-SVR provides a good generalization ability to approximate different kinds of nonlinear functions without overfitting.</p><p>In the same fashion, the other two rounds of cross validation are calculated and interference errors are listed in <xref ref-type="table" rid="t3-sensors-12-14537">Table 3</xref>. In <xref ref-type="table" rid="t3-sensors-12-14537">Table 3</xref>, all interference errors are reduced to less than 1.6% FS. after decoupling by <italic>&#x003b5;</italic>-SVR. Compared with <xref ref-type="table" rid="t1-sensors-12-14537">Table 1</xref>, the decoupling accuracy is much more stable because no overfitting happens. Therefore, the proposed decoupling algorithm based on our coupling error model and <italic>&#x003b5;</italic>-SVR is more robust.</p></sec><sec><label>4.3.</label><title>Processing Time</title><p>Besides decoupling accuracy, another crucial criterion for a successful decoupling algorithm is the processing speed of both model establishment and decoupling an output voltage vector in an actual force perception task, especially the latter for on-line task purposes. To evaluate the processing speed, the elapsed time of the above two stages is recorded and the whole process is repeated 10 times. All calculations are done on a Windows XP Inter(R) Xeon(TM) 2 QUAD CPU, 3.0 GHz processor with 3.00 GB RAM. An overview of the averaged elapsed time is shown in <xref ref-type="table" rid="t4-sensors-12-14537">Table 4</xref>. <xref ref-type="table" rid="t4-sensors-12-14537">Table 4</xref> shows that the elapsed time of the proposed algorithm in both the model establishment and the decoupling of an output voltage vector is less than decoupling by a standard RBF NN. <italic>&#x003b5;</italic>-SVR proves to be fast regressions. The elapsed time of decoupling a certain output voltage vector using a coupling error model based on <italic>&#x003b5;</italic>-SVR is less than 0.001 s. This means that the decoupling frequency is higher than 1,000 Hz. The speed of testing process based on <italic>&#x003b5;</italic>-SVR is fast.</p><p>Summarizing, the calculation results of the decoupling methods demonstrate that our decoupling method based on our coupling error model and <italic>&#x003b5;</italic>-SVRs has high reliability and fast running speed when no gross errors exist in the calibration data. In the next section, we will artificially add gross errors to the calibration data and analyze the decoupling method's robustness to gross errors.</p></sec><sec><label>4.4.</label><title>Robustness to Gross Errors</title><p>Now we simulate the decoupling algorithm's reaction to gross errors. The gross errors in calibration data are also called <italic>outliers</italic>. As the quantity of gross errors in calibration data is always small, in our research, only one gross error is generated in one dimension while the calibration data of other dimensions remain the same. Here we take the first round of cross validation for example. The decoupling process is the same as Section 4.2. We artificially generate a gross error into the calibration data in X direction to test the gross error's effect on the decoupling accuracy in all dimensions. The gross error is added artificially by arbitrarily moving a point away from its initial location.</p><p>As no gross errors are introduced into the calibration data of other dimensions, the fitting results of functions in Y direction and Z direction will remain the same as shown in <xref ref-type="fig" rid="f6-sensors-12-14537">Figures 6</xref> and <xref ref-type="fig" rid="f7-sensors-12-14537">7</xref>. The fitting results of the non-coupling function <italic>&#x003c9;<sub>x</sub></italic><sub>()</sub> and corrected-coupling functions <italic>&#x003c7;<sub>xy</sub></italic>() and <italic>&#x003c7;<sub>xz</sub></italic>() in X direction with the gross error (plotted with red circles) are shown in <xref ref-type="fig" rid="f8-sensors-12-14537">Figures 8</xref> and <xref ref-type="fig" rid="f9-sensors-12-14537">9</xref>. The inverse function of <italic>&#x003c9;<sub>x</sub></italic><sub>()</sub> is obtained as:
<disp-formula id="FD16"><label>(14)</label><mml:math id="mm30"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>&#x003c9;</mml:mi><mml:mi>x</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>74.193</mml:mn><mml:msub><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula></p><p>Comparing <xref ref-type="fig" rid="f9-sensors-12-14537">Figure 9</xref> with <xref ref-type="fig" rid="f7-sensors-12-14537">Figure 7</xref>, when the obtained calibration data contain a gross error (outlier), the <italic>&#x003b5;</italic>-SVR is not sensitive to the gross error and performs with high reliability, which correspond to the analysis in Section 2.2.2. Consequently, the proposed decoupling algorithm based on <italic>&#x003b5;</italic>-SVR displays a strong robustness to the gross error. The calculated interference errors of test data I and test data II under the gross error's effect are listed in <xref ref-type="table" rid="t5-sensors-12-14537">Table 5</xref>. Comparing <xref ref-type="table" rid="t5-sensors-12-14537">Table 5</xref> with <xref ref-type="table" rid="t3-sensors-12-14537">Table 3</xref>, when the gross error is artificially introduced, <italic>&#x003b3;<sub>x</sub></italic>, <italic>&#x003b3;<sub>y</sub></italic> and <italic>&#x003b3;<sub>z</sub></italic> after decoupling by <italic>&#x003b5;</italic>-SVR of both test data I and test data II seem almost unchanged. The comparison of interference errors also confirms that <italic>&#x003b5;</italic>-SVR is robust to gross errors.</p></sec></sec><sec sec-type="conclusions"><label>5.</label><title>Conclusions</title><p>In this paper, a robust decoupling algorithm to efficiently reduce coupling errors for 3-axis force sensors is presented. The decoupling algorithm is based on the establishment of a novel coupling error model and <italic>&#x003b5;</italic>-SVR. In the coupling error model, input forces are partitioned into prime forces and disturbing forces, and the corresponding output voltages are partitioned into prime voltages and coupling error elements. The structure of the coupling error model makes the decoupling process in one dimension separated from other dimensions. Linear relationships between prime forces and prime voltages in every dimension are fitted by LSM. Nonlinear relationships between disturbing forces and corresponding coupling error elements are fitted by <italic>&#x003b5;</italic>-SVR.</p><p>The experimental results show the effectiveness of the decoupling method. All interference errors are reduced to less than 1.6%. Compared with decoupling algorithm using one standard MIMO RBF NN, the proposed decoupling algorithm demonstrates a better tolerance to noises and faster calculation speed (with the decoupling frequency higher than 1,000 Hz). It also shows robustness to gross errors. As a result, compared with existing decoupling methods, the decoupling algorithm based on the proposed coupling error model and <italic>&#x003b5;</italic>-SVR is much more reliable in complex scenarios.</p></sec></body><back><ack><p>This work was supported in part by the National Natural High Technology Research and Development Program of China (863 Program) (No. 2008AA040202), Natural Science Foundation Project of Jiangsu Province (No. DK2010063), Scientific and Technological Research Project of Changzhou (No. CE20100022).</p></ack><ref-list><title>References</title><ref id="b1-sensors-12-14537"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Perry</surname><given-names>D.</given-names></name></person-group><article-title>Multi-axis force and torque sensing</article-title><source>Sens. Rev.</source><year>1997</year><volume>17</volume><fpage>117</fpage><lpage>120</lpage></element-citation></ref><ref id="b2-sensors-12-14537"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lefebvre</surname><given-names>T.</given-names></name><name><surname>Xiao</surname><given-names>J.</given-names></name><name><surname>Bruyninckx</surname><given-names>H.</given-names></name><name><surname>De Gersem</surname><given-names>G.</given-names></name></person-group><article-title>Active compliant motion: A survey</article-title><source>Adv. Robot.</source><year>2005</year><volume>19</volume><fpage>479</fpage><lpage>499</lpage></element-citation></ref><ref id="b3-sensors-12-14537"><label>3.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Siciliano</surname><given-names>B.</given-names></name><name><surname>Villani</surname><given-names>L.</given-names></name></person-group><source>Robot Force Control</source><publisher-name>Springer</publisher-name><publisher-loc>Napoli, Italy</publisher-loc><year>1999</year><volume>540</volume></element-citation></ref><ref id="b4-sensors-12-14537"><label>4.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Siciliano</surname><given-names>B.</given-names></name><name><surname>Khatib</surname><given-names>O.</given-names></name></person-group><article-title>Force Control</article-title><source>Springer Handbook of Robotics</source><publisher-name>Springer-Verlag New York Inc</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>2008</year><fpage>161</fpage><lpage>185</lpage></element-citation></ref><ref id="b5-sensors-12-14537"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>G.</given-names></name><name><surname>Song</surname><given-names>A.</given-names></name><name><surname>Li</surname><given-names>H.</given-names></name></person-group><article-title>Adaptive impedance control for upper-limb rehabilitation robot using evolutionary dynamic recurrent fuzzy neural network</article-title><source>J. Intell. Robot. Syst.</source><year>2011</year><volume>62</volume><fpage>501</fpage><lpage>525</lpage></element-citation></ref><ref id="b6-sensors-12-14537"><label>6.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Nagata</surname><given-names>F.</given-names></name><name><surname>Kusumoto</surname><given-names>Y.</given-names></name><name><surname>Watanabe</surname><given-names>K.</given-names></name><name><surname>Tsuda</surname><given-names>K.</given-names></name><name><surname>Yasuda</surname><given-names>K.</given-names></name><name><surname>Yokoyama</surname><given-names>K.</given-names></name><name><surname>Omoto</surname><given-names>M.</given-names></name><name><surname>Miyako</surname><given-names>H.</given-names></name></person-group><article-title>Polishing Robot for PET Bottle Molds Using a Learning-Based Hybrid Position/Force Controller</article-title><conf-name>Proceedings of the 5th Asian Control Conference</conf-name><conf-loc>Melbourne, Australia</conf-loc><conf-date>June 2004</conf-date><fpage>914</fpage><lpage>921</lpage></element-citation></ref><ref id="b7-sensors-12-14537"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Asada</surname><given-names>H.</given-names></name></person-group><article-title>A perturbation/correlation method for force guided robot assembly</article-title><source>IEEE Trans. Robot. Autom.</source><year>1999</year><volume>15</volume><fpage>764</fpage><lpage>773</lpage></element-citation></ref><ref id="b8-sensors-12-14537"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Song</surname><given-names>A.</given-names></name><name><surname>Wu</surname><given-names>J.</given-names></name><name><surname>Qin</surname><given-names>G.</given-names></name><name><surname>Huang</surname><given-names>W.</given-names></name></person-group><article-title>A novel self-decoupled four degree-of-freedom wrist force/torque sensor</article-title><source>Measurement</source><year>2007</year><volume>40</volume><fpage>883</fpage><lpage>891</lpage></element-citation></ref><ref id="b9-sensors-12-14537"><label>9.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Beyeler</surname><given-names>F.</given-names></name><name><surname>Muntwyler</surname><given-names>S.</given-names></name><name><surname>Nelson</surname><given-names>B.</given-names></name></person-group><article-title>Design and Calibration of a Microfabricated 6-Axis Force-Torque Sensor for Microrobotic Applications</article-title><conf-name>Proceedings of the International Conference on Robotics and Automation</conf-name><conf-loc>Zurich, Switzerland</conf-loc><conf-date>May 2009</conf-date><fpage>520</fpage><lpage>525</lpage></element-citation></ref><ref id="b10-sensors-12-14537"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>K.</given-names></name><name><surname>Sun</surname><given-names>Y.</given-names></name><name><surname>Voyles</surname><given-names>R.</given-names></name><name><surname>Nelson</surname><given-names>B.</given-names></name></person-group><article-title>Calibration of multi-axis MEMS force sensors using the shape-from-motion method</article-title><source>IEEE Sens. J.</source><year>2007</year><volume>7</volume><fpage>344</fpage><lpage>351</lpage></element-citation></ref><ref id="b11-sensors-12-14537"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Oddo</surname><given-names>C.</given-names></name><name><surname>Valdastri</surname><given-names>P.</given-names></name><name><surname>Beccai</surname><given-names>L.</given-names></name><name><surname>Roccella</surname><given-names>S.</given-names></name><name><surname>Carrozza</surname><given-names>M.</given-names></name><name><surname>Dario</surname><given-names>P.</given-names></name></person-group><article-title>Investigation on calibration methods for multi-axis, linear and redundant force sensors</article-title><source>Meas. Sci. Technol.</source><year>2007</year><volume>18</volume><fpage>623</fpage><lpage>631</lpage></element-citation></ref><ref id="b12-sensors-12-14537"><label>12.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Voyles</surname><given-names>R.</given-names></name><name><surname>Morrow</surname><given-names>J.</given-names></name><name><surname>Khosla</surname><given-names>P.</given-names></name></person-group><article-title>Shape from Motion Approach to Rapid and Precise Force/Torque Sensor Calibration</article-title><conf-name>Proceedings of the International Mechanical Engineering Congress and Exposition</conf-name><conf-loc>San Francisco, USA</conf-loc><conf-date>November 1995</conf-date><fpage>67</fpage><lpage>73</lpage></element-citation></ref><ref id="b13-sensors-12-14537"><label>13.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Cao</surname><given-names>H.</given-names></name><name><surname>Yu</surname><given-names>Y.</given-names></name><name><surname>Ge</surname><given-names>Y.</given-names></name></person-group><article-title>A Research of Multi-Axis Force Sensor Static Decoupling Method Based on Neural Network</article-title><conf-name>Proceedings of the International Conference on Automation and Logistics</conf-name><conf-loc>Shenyang, China</conf-loc><conf-date>August 2009</conf-date><fpage>875</fpage><lpage>879</lpage></element-citation></ref><ref id="b14-sensors-12-14537"><label>14.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Lei</surname><given-names>J.</given-names></name><name><surname>Qiu</surname><given-names>L.</given-names></name><name><surname>Liu</surname><given-names>M.</given-names></name><name><surname>Song</surname><given-names>Q.</given-names></name><name><surname>Ge</surname><given-names>Y.</given-names></name></person-group><article-title>Application of Neural Network to Nonlinear Static Decoupling of Robot Wrist Force Sensor</article-title><conf-name>Proceedings of the 6th World Congress on Intelligent Control and Automation</conf-name><conf-loc>Dalian, China</conf-loc><conf-date>October 2006</conf-date><fpage>5282</fpage><lpage>5285</lpage></element-citation></ref><ref id="b15-sensors-12-14537"><label>15.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Ming</surname><given-names>D.</given-names></name><name><surname>Zhang</surname><given-names>X.</given-names></name><name><surname>Liu</surname><given-names>X.</given-names></name><name><surname>Wan</surname><given-names>B.</given-names></name><name><surname>Hu</surname><given-names>Y.</given-names></name><name><surname>Luk</surname><given-names>K.</given-names></name></person-group><article-title>Nonlinear Static Decoupling of Six-Dimension Force Sensor for Walker Dynamometer System Based on Artificial Neural Network</article-title><conf-name>Proceedings of the International Conference on Computational Intelligence for Measurement Systems and Applications</conf-name><conf-loc>Hong Kong</conf-loc><conf-date>May 2009</conf-date><fpage>14</fpage><lpage>17</lpage></element-citation></ref><ref id="b16-sensors-12-14537"><label>16.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Cristianini</surname><given-names>N.</given-names></name><name><surname>Shawe-Taylor</surname><given-names>J.</given-names></name></person-group><source>An Introduction to Support Vector Machines: And Other Kernel-Based Learning Methods</source><publisher-name>Cambridge Univ. Press</publisher-name><publisher-loc>Cambridge, UK</publisher-loc><year>2000</year></element-citation></ref><ref id="b17-sensors-12-14537"><label>17.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guo</surname><given-names>J.</given-names></name><name><surname>He</surname><given-names>Y.</given-names></name><name><surname>Liu</surname><given-names>C.</given-names></name></person-group><article-title>Nonlinear correction of photoelectric displacement sensor based on least square support vector machine</article-title><source>J. Cent. S. Univ. Technol.</source><year>2011</year><volume>18</volume><fpage>1614</fpage><lpage>1618</lpage></element-citation></ref><ref id="b18-sensors-12-14537"><label>18.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>X.</given-names></name></person-group><article-title>Non-Linearity Estimation and Temperature Compensation of Capacitor Pressure Sensors Using Least Square Support Vector Regression</article-title><conf-name>Proceedings of the International Symposium on Knowledge Acquisition and Modeling Workshop</conf-name><conf-loc>Wuhan, China</conf-loc><conf-date>December 2008</conf-date><fpage>1161</fpage><lpage>1164</lpage></element-citation></ref><ref id="b19-sensors-12-14537"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smola</surname><given-names>A.</given-names></name><name><surname>Sch&#x000f6;lkopf</surname><given-names>B.</given-names></name></person-group><article-title>A tutorial on support vector regression</article-title><source>Stat. Comput.</source><year>2004</year><volume>14</volume><fpage>199</fpage><lpage>222</lpage></element-citation></ref><ref id="b20-sensors-12-14537"><label>20.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Vapnik</surname><given-names>V.</given-names></name></person-group><source>Statistical Learning Theory</source><publisher-name>Wiley</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>1998</year></element-citation></ref><ref id="b21-sensors-12-14537"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Verrelst</surname><given-names>J.</given-names></name><name><surname>Mu&#x000f1;oz</surname><given-names>J.</given-names></name><name><surname>Alonso</surname><given-names>L.</given-names></name><name><surname>Delegido</surname><given-names>J.</given-names></name><name><surname>Rivera</surname><given-names>J.</given-names></name><name><surname>Camps-Valls</surname><given-names>G.</given-names></name><name><surname>Moreno</surname><given-names>J.</given-names></name></person-group><article-title>Machine learning regression algorithms for biophysical parameter retrieval: Opportunities for sentinel-2 and-3</article-title><source>Remote Sens. Environ.</source><year>2012</year><volume>118</volume><fpage>127</fpage><lpage>139</lpage></element-citation></ref><ref id="b22-sensors-12-14537"><label>22.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>L.</given-names></name></person-group><source>Support Vector Machines: Theory and Applications</source><publisher-name>Springer Verlag</publisher-name><publisher-loc>Singapore</publisher-loc><year>2005</year><volume>177</volume></element-citation></ref><ref id="b23-sensors-12-14537"><label>23.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Platt</surname><given-names>J.C.</given-names></name></person-group><article-title>Fast Training of Support Vector Machines Using Sequential Minimal Optimization</article-title><source>Advances in Kernel Methods: Support Vector Machines</source><publisher-name>MIT Press</publisher-name><publisher-loc>Cambridge, MA, USA</publisher-loc><year>1998</year><fpage>185</fpage><lpage>208</lpage></element-citation></ref><ref id="b24-sensors-12-14537"><label>24.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Dahai</surname><given-names>L.</given-names></name><name><surname>Tianshi</surname><given-names>L.</given-names></name></person-group><article-title>On-Line Robust Modeling of Nonlinear Systems Using Support Vector Regression</article-title><conf-name>Proceedings of the 2nd International Conference on Advanced Computer Control</conf-name><conf-loc>Shenyang, China</conf-loc><conf-date>March 2010</conf-date><fpage>204</fpage><lpage>208</lpage></element-citation></ref><ref id="b25-sensors-12-14537"><label>25.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chuang</surname><given-names>C.</given-names></name><name><surname>Su</surname><given-names>S.</given-names></name><name><surname>Jeng</surname><given-names>J.</given-names></name><name><surname>Hsiao</surname><given-names>C.</given-names></name></person-group><article-title>Robust support vector regression networks for function approximation with outliers</article-title><source>IEEE Trans. Neural Netw.</source><year>2002</year><volume>13</volume><fpage>1322</fpage><lpage>1330</lpage><pub-id pub-id-type="pmid">18244530</pub-id></element-citation></ref><ref id="b26-sensors-12-14537"><label>26.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ma</surname><given-names>J.</given-names></name><name><surname>Song</surname><given-names>A.</given-names></name></person-group><article-title>Development of a novel two-axis force sensor for chinese massage robot</article-title><source>Appl. Mech. Mater.</source><year>2012</year><volume>103</volume><fpage>299</fpage><lpage>304</lpage></element-citation></ref><ref id="b27-sensors-12-14537"><label>27.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Berkelman</surname><given-names>P.</given-names></name><name><surname>Whitcomb</surname><given-names>L.</given-names></name><name><surname>Taylor</surname><given-names>R.</given-names></name><name><surname>Jensen</surname><given-names>P.</given-names></name></person-group><article-title>A miniature microsurgical instrument tip force sensor for enhanced force feedback during robot-assisted manipulation</article-title><source>IEEE Trans. Robot. Autom.</source><year>2003</year><volume>19</volume><fpage>917</fpage><lpage>921</lpage></element-citation></ref><ref id="b28-sensors-12-14537"><label>28.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chao</surname><given-names>L.</given-names></name><name><surname>Yin</surname><given-names>C.</given-names></name></person-group><article-title>The six-component force sensor for measuring the loading of the feet in locomotion</article-title><source>Mater. Des.</source><year>1999</year><volume>20</volume><fpage>237</fpage><lpage>244</lpage></element-citation></ref><ref id="b29-sensors-12-14537"><label>29.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>L.</given-names></name><name><surname>Song</surname><given-names>A.</given-names></name></person-group><article-title>A Novel Three Degree-of-Freedom Force Sensor</article-title><conf-name>Proceedings of the International Conference on Measuring Technology and Mechatronics Automation</conf-name><conf-loc>Zhangjiajie, China</conf-loc><conf-date>April 2009</conf-date><fpage>77</fpage><lpage>80</lpage></element-citation></ref><ref id="b30-sensors-12-14537"><label>30.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>K.</given-names></name><name><surname>Li</surname><given-names>C.</given-names></name><name><surname>Zhu</surname><given-names>Z.</given-names></name></person-group><article-title>Dynamic modeling and compensation of robot six-axis wrist force/torque sensor</article-title><source>IEEE Trans. Instrum. Meas.</source><year>2007</year><volume>56</volume><fpage>2094</fpage><lpage>2100</lpage></element-citation></ref><ref id="b31-sensors-12-14537"><label>31.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chang</surname><given-names>C.C.</given-names></name><name><surname>Lin</surname><given-names>C.J.</given-names></name></person-group><article-title>LIBSVM: A library for support vector machines</article-title><source>ACM Trans. Intell. Syst. Technol.</source><year>2011</year><volume>2</volume><fpage>1</fpage><lpage>27</lpage></element-citation></ref><ref id="b32-sensors-12-14537"><label>32.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fan</surname><given-names>R.</given-names></name><name><surname>Chen</surname><given-names>P.</given-names></name><name><surname>Lin</surname><given-names>C.</given-names></name></person-group><article-title>Working set selection using second order information for training support vector machines</article-title><source>J. Mach. Learn. Res.</source><year>2005</year><volume>6</volume><fpage>1889</fpage><lpage>1918</lpage></element-citation></ref></ref-list></back><floats-group><fig id="f1-sensors-12-14537" position="float"><label>Figure 1.</label><caption><p>A coupling error model of 3-axis force sensors.</p></caption><graphic xlink:href="sensors-12-14537f1"/></fig><fig id="f2-sensors-12-14537" position="float"><label>Figure 2.</label><caption><p>Graphic description of the <italic>&#x003b5;</italic>-SVR model for a linear case.</p></caption><graphic xlink:href="sensors-12-14537f2"/></fig><fig id="f3-sensors-12-14537" position="float"><label>Figure 3.</label><caption><p>The flow chart of the whole decoupling process.</p></caption><graphic xlink:href="sensors-12-14537f3"/></fig><fig id="f4-sensors-12-14537" position="float"><label>Figure 4.</label><caption><p>Diagram of static calibration experiment setup: (1) loading plate, (2) calibration shaft, (3) three-axis force sensor, (4) indexing plate, (5) pulley block, (6) weights, (7) base.</p></caption><graphic xlink:href="sensors-12-14537f4"/></fig><fig id="f5-sensors-12-14537" position="float"><label>Figure 5.</label><caption><p>The static calibration experiment setup.</p></caption><graphic xlink:href="sensors-12-14537f5"/></fig><fig id="f6-sensors-12-14537" position="float"><label>Figure 6.</label><caption><p>Linear fittings of non-coupling functions.</p></caption><graphic xlink:href="sensors-12-14537f6"/></fig><fig id="f7-sensors-12-14537" position="float"><label>Figure 7.</label><caption><p>Approximation of corrected coupling functions by <italic>&#x003b5;</italic>-SVR <italic>vs.</italic> by RBF NN.</p></caption><graphic xlink:href="sensors-12-14537f7"/></fig><fig id="f8-sensors-12-14537" position="float"><label>Figure 8.</label><caption><p>The fitting result of the <italic>&#x003c9;<sub>x</sub></italic> for calibration data with gross error.</p></caption><graphic xlink:href="sensors-12-14537f8"/></fig><fig id="f9-sensors-12-14537" position="float"><label>Figure 9.</label><caption><p>The fitting results of <italic>&#x003c7;<sub>xy</sub></italic>() and <italic>&#x003c7;<sub>xz</sub></italic> for calibration data with the gross error.</p></caption><graphic xlink:href="sensors-12-14537f9"/></fig><table-wrap id="t1-sensors-12-14537" position="float"><label>Table 1.</label><caption><p>Error analysis of initial data and decoupling by a standard MIMO RBF.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top" rowspan="3" colspan="1"/><th align="left" valign="top" rowspan="3" colspan="1"/><th colspan="2" align="center" valign="top" rowspan="1"><italic>&#x003b3;<sub>x</sub></italic></th><th colspan="2" align="center" valign="top" rowspan="1"><italic>&#x003b3;<sub>y</sub></italic></th><th colspan="2" align="center" valign="top" rowspan="1"><italic>&#x003b3;<sub>z</sub></italic></th></tr><tr><th valign="bottom" colspan="6" rowspan="1">
<hr/></th></tr><tr><th align="center" valign="top" rowspan="1" colspan="1">initial data</th><th align="center" valign="top" rowspan="1" colspan="1">decoupled by RBF</th><th align="center" valign="top" rowspan="1" colspan="1">initial data</th><th align="center" valign="top" rowspan="1" colspan="1">decoupled by RBF</th><th align="center" valign="top" rowspan="1" colspan="1">initial data</th><th align="center" valign="top" rowspan="1" colspan="1">decoupled by RBF</th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">the first</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">2.54%</td><td align="center" valign="top" rowspan="1" colspan="1">0.42%</td><td align="center" valign="top" rowspan="1" colspan="1"><bold>2.57%</bold></td><td align="center" valign="top" rowspan="1" colspan="1"><bold>3.73%</bold></td><td align="center" valign="top" rowspan="1" colspan="1">2.36%</td><td align="center" valign="top" rowspan="1" colspan="1">0.17%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">2.37%</td><td align="center" valign="top" rowspan="1" colspan="1">0.61%</td><td align="center" valign="top" rowspan="1" colspan="1"><bold>2.52%</bold></td><td align="center" valign="top" rowspan="1" colspan="1"><bold>7.99%</bold></td><td align="center" valign="top" rowspan="1" colspan="1">2.55%</td><td align="center" valign="top" rowspan="1" colspan="1">0.23%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">the second</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">2.31%</td><td align="center" valign="top" rowspan="1" colspan="1">1.02%</td><td align="center" valign="top" rowspan="1" colspan="1">2.59%</td><td align="center" valign="top" rowspan="1" colspan="1">2.32%</td><td align="center" valign="top" rowspan="1" colspan="1">2.98%</td><td align="center" valign="top" rowspan="1" colspan="1">0.71%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1"><bold>2.73%</bold></td><td align="center" valign="top" rowspan="1" colspan="1"><bold>3.45%</bold></td><td align="center" valign="top" rowspan="1" colspan="1">2.65%</td><td align="center" valign="top" rowspan="1" colspan="1">0.74%</td><td align="center" valign="top" rowspan="1" colspan="1">2.81%</td><td align="center" valign="top" rowspan="1" colspan="1">0.69%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">the third</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">2.40%</td><td align="center" valign="top" rowspan="1" colspan="1">0.49%</td><td align="center" valign="top" rowspan="1" colspan="1">2.68%</td><td align="center" valign="top" rowspan="1" colspan="1">0.31%</td><td align="center" valign="top" rowspan="1" colspan="1">2.57%</td><td align="center" valign="top" rowspan="1" colspan="1">0.34%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">2.32%</td><td align="center" valign="top" rowspan="1" colspan="1">0.26%</td><td align="center" valign="top" rowspan="1" colspan="1">2.71%</td><td align="center" valign="top" rowspan="1" colspan="1">0.31%</td><td align="center" valign="top" rowspan="1" colspan="1">2.14%</td><td align="center" valign="top" rowspan="1" colspan="1">0.32%</td></tr></tbody></table></table-wrap><table-wrap id="t2-sensors-12-14537" position="float"><label>Table 2.</label><caption><p>Initial parameters used by the LIBSVM train tool.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" rowspan="1" colspan="1"><bold>Parameter</bold></th><th align="center" valign="top" rowspan="1" colspan="1"><bold>Value</bold></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">SVM type</td><td align="center" valign="top" rowspan="1" colspan="1">3(<italic>&#x003b5;</italic>-SVR)</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Kernel function</td><td align="center" valign="top" rowspan="1" colspan="1">2(RBF)</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b4;</italic><sup>2</sup> (Standard deviation of kernel function)</td><td align="center" valign="top" rowspan="1" colspan="1">1</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">C (Regularization parameter)</td><td align="center" valign="top" rowspan="1" colspan="1">1000</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b5;</italic> (Deviation)</td><td align="center" valign="top" rowspan="1" colspan="1">0.0001</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Tolerance</td><td align="center" valign="top" rowspan="1" colspan="1">0.001</td></tr></tbody></table></table-wrap><table-wrap id="t3-sensors-12-14537" position="float"><label>Table 3.</label><caption><p>Error analysis of decoupling algorithm by <italic>&#x003b5;</italic>-SVRs.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" rowspan="1" colspan="1"/><th align="center" valign="top" rowspan="1" colspan="1"/><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>x</sub></italic></th><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>y</sub></italic></th><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>z</sub></italic></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">the first</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">1.69%</td><td align="center" valign="top" rowspan="1" colspan="1">1.33%</td><td align="center" valign="top" rowspan="1" colspan="1">0.82%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">1.45%</td><td align="center" valign="top" rowspan="1" colspan="1">1.28%</td><td align="center" valign="top" rowspan="1" colspan="1">0.59%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">the second</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">1.30%</td><td align="center" valign="top" rowspan="1" colspan="1">1.47%</td><td align="center" valign="top" rowspan="1" colspan="1">0.86%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">1.56%</td><td align="center" valign="top" rowspan="1" colspan="1">1.24%</td><td align="center" valign="top" rowspan="1" colspan="1">0.76%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">the third</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">1.43%</td><td align="center" valign="top" rowspan="1" colspan="1">1.52%</td><td align="center" valign="top" rowspan="1" colspan="1">0.67%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">1.48%</td><td align="center" valign="top" rowspan="1" colspan="1">1.57%</td><td align="center" valign="top" rowspan="1" colspan="1">0.83%</td></tr></tbody></table></table-wrap><table-wrap id="t4-sensors-12-14537" position="float"><label>Table 4.</label><caption><p>Mean elapsed time (in seconds) of the training process and the testing process.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" rowspan="1" colspan="1"/><th align="center" valign="top" rowspan="1" colspan="1"><bold>a RBF NN</bold></th><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b5;</italic><bold>-SVRs</bold></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">Establishment of the model</td><td align="center" valign="top" rowspan="1" colspan="1">80.5603</td><td align="center" valign="top" rowspan="1" colspan="1">3.3702</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Decoupling of an output voltage vector</td><td align="center" valign="top" rowspan="1" colspan="1">0.1404</td><td align="center" valign="top" rowspan="1" colspan="1">0.00093</td></tr></tbody></table></table-wrap><table-wrap id="t5-sensors-12-14537" position="float"><label>Table 5.</label><caption><p>Error analysis of decoupling by <italic>&#x003b5;</italic>-SVRs when a gross error is introduced.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" rowspan="1" colspan="1"/><th align="center" valign="top" rowspan="1" colspan="1"/><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>x</sub></italic></th><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>y</sub></italic></th><th align="center" valign="top" rowspan="1" colspan="1"><italic>&#x003b3;<sub>z</sub></italic></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">the first</td><td align="center" valign="top" rowspan="1" colspan="1">test I</td><td align="center" valign="top" rowspan="1" colspan="1">1.41%</td><td align="center" valign="top" rowspan="1" colspan="1">1.51%</td><td align="center" valign="top" rowspan="1" colspan="1">0.71%</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">cross-validation</td><td align="center" valign="top" rowspan="1" colspan="1">test II</td><td align="center" valign="top" rowspan="1" colspan="1">1.44%</td><td align="center" valign="top" rowspan="1" colspan="1">1.56%</td><td align="center" valign="top" rowspan="1" colspan="1">0.87%</td></tr></tbody></table></table-wrap></floats-group></article>