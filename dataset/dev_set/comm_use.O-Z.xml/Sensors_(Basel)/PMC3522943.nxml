<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>Molecular Diversity Preservation International (MDPI)</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">23202190</article-id><article-id pub-id-type="pmc">3522943</article-id><article-id pub-id-type="doi">10.3390/s121114851</article-id><article-id pub-id-type="publisher-id">sensors-12-14851</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Network Modeling and Energy-Efficiency Optimization for Advanced Machine-to-Machine Sensor Networks</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Jung</surname><given-names>Sungmo</given-names></name><xref ref-type="aff" rid="af1-sensors-12-14851"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Kim</surname><given-names>Jong Hyun</given-names></name><xref ref-type="aff" rid="af2-sensors-12-14851"><sup>2</sup></xref></contrib><contrib contrib-type="author"><name><surname>Kim</surname><given-names>Seoksoo</given-names></name><xref ref-type="aff" rid="af1-sensors-12-14851"><sup>1</sup></xref><xref ref-type="corresp" rid="c1-sensors-12-14851"><sup>*</sup></xref></contrib></contrib-group><aff id="af1-sensors-12-14851"><label>1</label> Department of Multimedia, Hannam University, Daejeon 306-791, Korea; E-Mail: <email>sungmoj@gmail.com</email></aff><aff id="af2-sensors-12-14851"><label>2</label> Electronics and Telecommunications Research Institute, Daejeon 305-700, Korea; E-Mail: <email>jhk@etri.re.kr</email></aff><author-notes><corresp id="c1-sensors-12-14851"><label>*</label> Author to whom correspondence should be addressed; E-Mail: <email>sskim0123@naver.com</email>; Tel.: +82-42-629-8336; Fax: +82-42-629-8093.</corresp></author-notes><pub-date pub-type="collection"><year>2012</year></pub-date><pub-date pub-type="epub"><day>05</day><month>11</month><year>2012</year></pub-date><volume>12</volume><issue>11</issue><fpage>14851</fpage><lpage>14861</lpage><history><date date-type="received"><day>30</day><month>8</month><year>2012</year></date><date date-type="rev-recd"><day>29</day><month>10</month><year>2012</year></date><date date-type="accepted"><day>31</day><month>10</month><year>2012</year></date></history><permissions><copyright-statement>&#x000a9; 2012 by the authors; licensee MDPI, Basel, Switzerland.</copyright-statement><copyright-year>2012</copyright-year><license><license-p><!--CREATIVE COMMONS-->This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>).</license-p></license></permissions><abstract><p>Wireless machine-to-machine sensor networks with multiple radio interfaces are expected to have several advantages, including high spatial scalability, low event detection latency, and low energy consumption. Here, we propose a network model design method involving network approximation and an optimized multi-tiered clustering algorithm that maximizes node lifespan by minimizing energy consumption in a non-uniformly distributed network. Simulation results show that the cluster scales and network parameters determined with the proposed method facilitate a more efficient performance compared to existing methods.</p></abstract><kwd-group><kwd>clustering algorithm</kwd><kwd>lifespan</kwd><kwd>machine to machine</kwd><kwd>multiple radio interfaces</kwd><kwd>network modeling</kwd><kwd>wireless sensor networks</kwd></kwd-group></article-meta></front><body><sec><label>1.</label><title>Introduction</title><p>In machine-to-machine (M2M) sensor networks, individual nodes may be stationed in a non-uniform manner, depending on the topography of the environment and the specific application. In such cases, it is particularly important to form uniform clusters in the network. To this end, advanced sensor nodes with multiple radio interfaces are expected to have several advantages, including high spatial scalability, low event detection latency, and low energy consumption [<xref ref-type="bibr" rid="b1-sensors-12-14851">1</xref>]. However, it is also essential to develop methods to maximize network lifespan by minimizing the energy consumption of sensor nodes.</p><p>Several hierarchical clustering methods (LEACH, PEGASIS, TEEN, <italic>etc.</italic>) have been suggested for increasing network energy efficiency, and a variety of cluster head (CH) election methods have been studied. In addition, a few advanced methods (M-LEACH, HEED, EEHC, <italic>etc.</italic>) have been proposed for mobile nodes such as those in an M2M sensor network [<xref ref-type="bibr" rid="b2-sensors-12-14851">2</xref>]. However, these methods have several limitations. First, efficient cluster formation becomes more difficult with increasing network scale. Second, if the sensor nodes are not evenly distributed in the network environment, uniform cluster formation is impossible.</p><p>Here, we propose a network modeling method and an energy-efficient clustering algorithm for advanced M2M sensor networks. We also present the results of simulations in which the proposed method is compared with existing methods.</p></sec><sec><label>2.</label><title>Related Research</title><sec><label>2.1.</label><title>Low Energy Adaptive Clustering Hierarchy</title><p>The LEACH [<xref ref-type="bibr" rid="b3-sensors-12-14851">3</xref>] protocol is an energy-efficient protocol that extends system lifetime. LEACH is designed for sensor networks where an end-user wants to remotely monitor the environment. In such a situation, the data from the individual nodes must be sent to a central base station (BS), often located far from the sensor network, through which the end-user can access the data. There are several desirable properties for protocols on these networks:
<list list-type="order"><list-item><p>Use 100 s&#x02013;1,000 s of nodes</p></list-item><list-item><p>Maximize system lifetime</p></list-item><list-item><p>Maximize network coverage</p></list-item><list-item><p>Use uniform, battery-operated nodes</p></list-item></list></p><p>Conventional network protocols, such as direct transmission, minimum transmission energy, multi-hop routing, and clustering all have drawbacks that don't allow them to achieve all the desirable properties. LEACH includes distributed cluster formation, local processing to reduce global communication, and randomized rotation of the CHs. These features allow LEACH to achieve the desired objectives.</p></sec><sec><label>2.2.</label><title>Power-Efficient Gathering in Sensor Information Systems</title><p>The PEGASIS [<xref ref-type="bibr" rid="b4-sensors-12-14851">4</xref>] protocol is a chain-based protocol. In general, the PEGASIS protocol presents twice or more performance in comparison with the LEACH one. However, PEGASIS causes redundant data transmissions since one of nodes on the chain is selected as the head node, regardless of the BSs location.</p></sec><sec><label>2.3.</label><title>Threshold Sensitive Energy Efficient Sensor Network</title><p>The TEEN [<xref ref-type="bibr" rid="b5-sensors-12-14851">5</xref>] protocol is a hierarchical clustering protocol, which groups sensors into clusters with each led by a CH. The sensors within a cluster report their sensed data to their CH. The CH sends aggregated data to higher level CH until the data reaches the sink. Thus, the sensor network architecture in TEEN is based on a hierarchical grouping where closer nodes form clusters and this process goes on the second level until the BS (Sink) is reached. TEEN is useful for applications where the users can control a trade-off between energy efficiency, data accuracy, and response time dynamically. TEEN uses a data-centric method with hierarchical approach.</p></sec><sec><label>2.4.</label><title>Multihop-LEACH</title><p>A LEACH CH always transmits data directly to the BS, regardless of the distance between them. To reduce energy, the M-LEACH [<xref ref-type="bibr" rid="b6-sensors-12-14851">6</xref>] protocol, another variant on the LEACH theme, chooses an optimal path between a CH and the BS through other CHs. These CHs transmit data to the CH which is nearest to BS. Finally, this CH sends data to BS. M-LEACH is almost the same as LEACH, but the difference is that the communication mode in M-LEACH is multi-hop between CHs and BS. M-LEACH has better energy efficiency than LEACH in many cases.</p></sec><sec><label>2.5.</label><title>Hybrid Energy-Efficient Distributed Clustering Approach</title><p>HEED [<xref ref-type="bibr" rid="b7-sensors-12-14851">7</xref>] is a hybrid: CHs are probabilistically selected based on their residual energy, and nodes join clusters such that communication cost is minimized. HEED parameters, such as the minimum selection probability and network operation interval, can be easily tuned to optimize resource usage according to the network density and application requirements. HEED achieves a connected multi-hop inter-cluster network when a specified density model and a specified relation between cluster range and transmission range hold.</p></sec><sec><label>2.6.</label><title>Energy Efficient Heterogeneous Clustering Approach</title><p>EEHC [<xref ref-type="bibr" rid="b8-sensors-12-14851">8</xref>] is a distributed randomized clustering algorithm that maximizes the lifetime of a network with a large number of sensor nodes. EEHC organizes the sensors in a network into clusters with a hierarchy of CHs. The CHs collect the information from the sensor nodes within their clusters and send an aggregated report through the hierarchy of CHs to the BS. EEHC assumes that communication environment is contention and error free. The energy consumed in network will depend on: (i) the probabilities of each sensor node becoming a CH at each level in the hierarchy and (ii) the maximum number of hops allowed between one cluster node and its CH. The optimal clustering parameters are obtained through hierarchical clustering to minimize the total energy consumption in the network. However, CHs in hierarchical model consume relatively more energy than other sensor nodes because CHs have more loads to handle. Hence, CHs may run out of their energy faster than other sensor nodes. Thus, EEHC can be run periodically for load balancing or triggered as the energy levels of the CHs fall below a certain threshold.</p></sec></sec><sec><label>3.</label><title>Network Model Design and Energy-Efficiency Optimization</title><sec><label>3.1.</label><title>Uniform Network Model</title><p>Consider a non-uniform network, such as the one shown in <xref ref-type="fig" rid="f1-sensors-12-14851">Figure 1(a)</xref>. The network is divided into sections centered around sink nodes to show the cluster density. Cluster formation in the low- and high-density areas of this network occurs as shown in <xref ref-type="fig" rid="f1-sensors-12-14851">Figure 1(b,c)</xref>, respectively. In these figures, the CH elects member nodes by using a logical-hop-count range and the shortest hop count in the 360&#x000b0; range. <xref ref-type="fig" rid="f1-sensors-12-14851">Figure 1(d)</xref> shows the result of hierarchical cluster formation. Shortest-hop-count-based 2-hop clustering was used at 60&#x000b0; intervals in order to generate the circles. In the angle range, the initial multi-hop cluster (<italic>C<sub>1</sub></italic>) is created using the shortest hop count. The terminal node sends a CH create request message to nodes within <italic>D</italic>+<italic>1</italic> hops from itself. <italic>CH<sub>2</sub></italic> and <italic>CH<sub>3</sub></italic> receive this request message as they are within <italic>D</italic>+<italic>1</italic> hops from <italic>C<sub>1</sub></italic>'s terminal node.</p><p>Thus, they form the new CHs of clusters <italic>C<sub>2</sub></italic> and <italic>C<sub>3</sub></italic>. However, some nodes receive duplicate cluster join messages. Such nodes must decide which cluster to join on the basis of the communication cost. Therefore, the network model should be constructed as a multi-tiered structure: the first tier collects intracluster data and the second tier collects information on CHs; the second tier begins from the sink node and extends toward the interior of the cluster.</p><p>The scale and topography of each cluster differ since the node density differs. Thus, we propose the network approximation model shown in <xref ref-type="fig" rid="f2-sensors-12-14851">Figure 2</xref>. All networks are approximated by a multi-tiered network, shown by a circle of radius <italic>L</italic>, and the constructed clusters are represented by the small circles of radius <italic>R</italic>. The network model has a donut-shaped ring structure, which is convenient for forming a set of clusters located at the same distance from the sink node.</p><p>Both the first- and second-tier clusters are approximated by the same method, and data transmission begins from the outermost ring and progresses toward the interior in a gradual manner. Ultimately, the data are passed to the sink node. At the first tier, the transmission distance is less than that at the second tier and so a relatively small amount of data is transmitted. At the second tier, in contrast, a relatively large amount of data is transmitted. Multiple radio interfaces are used for each tier to allow energy-efficient data transmission. Specifically, the first tier uses a low-speed radio interface and the second tier uses a high-speed radio interface.</p></sec><sec><label>3.2.</label><title>Use of Clustering Algorithm to Optimize Energy Efficiency</title><p>The clustering algorithm proposed here allows the formation of clusters of similar scales by using the network approximation modeling algorithm shown in Algorithm 1.</p><array><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1"><bold>Algorithm 1.</bold> Proposed clustering algorithm to optimize energy efficiency.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><italic>// Assign Initial-Value</italic></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># own.ID &#x02190; own ID</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># src.ID &#x02190; received own.ID</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># sink &#x02190; first sink node ID</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># sink.toward &#x02190; src.ID</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># provisional.CH &#x02190; true</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># msg.odr.RSSI, own.msg.odr.RSSI &#x02190; 0</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># thrhold.RSSI &#x02190; &#x003c1;</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># bc.elect.msg &#x02190; src.ID, hop.count, msg.odr.RSSI</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"># own.elect.msg &#x02190; own.ID, own.hop.count, own.msg.odr.RSSI</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">DO (hop.count = 0)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1"><italic>// Broadcast of CH Election Order Message from the First Sink-node</italic></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;IF (sink! = null)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;msg.odr &#x02190; sink, hop.count</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;broadcast msg.odr</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;ELSE</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;BREAK</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;<italic>// Cluster Head Election and Elected Message Broadcasting</italic></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;IF (get msg.odr(src.ID, hop.count)) THEN</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;own.msg.odr.RSSI &#x02190; RSSI value of msg.odr</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;ELSE IF (msg.odr.RSSI &#x0003c; thrhold.RSSI &#x02016; own.hop.count &#x0003c; hop.count &#x02016; msg.odr.RSSI &#x0003c; own.msg.odr.RSSI)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;own.hop.count &#x02190; hop.count</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;own.msg.odr.RSSI &#x02190; msg.odr.RSSI</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;generate sink.toward</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;bc.elect.msg &#x02190; own.elect.msg</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;broadcast bc.elect.msg</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;<italic>// Compare RSSI</italic></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;IF (get bc.elect.msg) THEN</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;elect.msg.RSSI &#x02190; RSSI value of elect.msg</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;ELSE IF (elect.msg.RSSI &#x0003c; thrhold.RSSI &#x02016; own.hop.count &#x0003c; hop.count)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;IF (own.msg.odr.RSSI &#x0003e; msg.odr.RSSI) then</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;&#x02003;provisional.CH &#x02190; false</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;&#x02003;BREAK</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;<italic>// Repeat Cluster Head Election</italic></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;IF (provisional.CH = true) THEN</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;SET self AS NEW CH</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;hop.count &#x02190; hop.count++</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;&#x02003;broadcast msg.odr(own.ID, hop.count)</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">&#x02003;ENDIF</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">WHILE (own.hop.count = &#x0221e;)</td></tr></tbody></array><p>The above algorithm begins broadcasting the CH election order message (<italic>msg.odr</italic>) from the initial sink node. <italic>msg.odr</italic> includes the ID of the node that transmitted the message (<italic>src.ID</italic>) and the hop count (<italic>hop.count</italic>) from the sink node. The neighboring nodes receive <italic>msg.odr</italic> and record the message signal strength (<italic>msg.odr.RSSI</italic>). For the clusters, there is a specified threshold value for the received signal strength indication (RSSI) (<italic>thrhold.RSSI</italic>), and only sensor nodes within the transmission range of the circle can receive <italic>msg.odr</italic> for network approximation modeling. The nodes that receive <italic>msg.odr</italic> broadcast the CH election message (<italic>elect.msg</italic>), which includes <italic>src.ID</italic>, <italic>hop.count</italic>, and <italic>msg.odr.RSSI</italic>.</p><p>The nodes that receive <italic>elect.msg</italic> compare <italic>own.hop.count</italic> with the received <italic>hop.count</italic> message. If they are not equal, then the comparison result is ignored and messages are received only from nodes within the circle. Then, the number of nodes that receive <italic>elect.msg</italic> is greater than the number of nodes belonging to <italic>S<sub>x</sub></italic> (set of nodes). The nodes that may belong to <italic>S<sub>x</sub></italic> compare <italic>own.msg.odr.RSSI</italic> with <italic>msg.odr.RSSI</italic>, which is contained in each received <italic>elect.msg</italic>. If their own value is less than the received value, they elect themselves as CHs. An elected CH is within the angle range, and it is the node farthest from the sink node, among the nodes that belong to <italic>S<sub>x</sub></italic>. The elected CHs increment <italic>hop.count</italic> by 1, broadcast <italic>msg.odr</italic>, and repeat the CH election process. There is a limit on the number of hops, and this limit is determined by the node density. Finally, they can assign their own cluster range and induct cluster members from the nodes within the range, as shown in <xref ref-type="fig" rid="f1-sensors-12-14851">Figure 1(d)</xref>.</p><p>In the above-suggested clustering algorithm, there is an upper limit for the density since there is no CH cluster without a CH in the previous hop being in the range of the <italic>thrhold.RSSI</italic> of the CHs. In addition, there is also a lower limit to the density since the CH election process is repeated until there are no nodes left. The upper and lower limits of the cluster density <italic>&#x003c1;</italic> are as follows:
<disp-formula id="FD1"><label>(1)</label><mml:math id="mm1"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:msqrt><mml:mn>3</mml:mn></mml:msqrt></mml:mrow><mml:mn>9</mml:mn></mml:mfrac><mml:mo>&#x02264;</mml:mo><mml:mi>&#x003c1;</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:msqrt><mml:mn>3</mml:mn></mml:msqrt></mml:mrow><mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:math></disp-formula></p></sec><sec><label>3.3.</label><title>Maximum Energy Consumption</title><p>To predict the network lifespan, we should determine the maximum energy consumption on the basis of the energy consumed by each node. To determine the maximum energy consumption, we define the (<italic>i</italic>,<italic>j</italic>)-th ring as the <italic>i</italic>-th ring in the first tier and the <italic>j</italic>-th ring in the second tier since each node is included in both tiers.</p><p>The first and second rings in the two tiers are candidates for the node with the maximum energy consumption. Thus, the maximum energy consumption range is decided by concentric rings consisting of the (<italic>1</italic>,<italic>1</italic>)-, (<italic>1</italic>,<italic>2</italic>)-, (<italic>2</italic>,<italic>1</italic>) and (<italic>2</italic>,<italic>2</italic>)-th rings.</p><p>The maximum energy consumption includes the <italic>wake-up</italic> energy, which is required to initialize the network from the sleep state. We propose that the maximum energy consumption rate is as follows:
<disp-formula id="FD2"><label>(2)</label><mml:math id="mm2"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mo>max</mml:mo><mml:mo>_</mml:mo><mml:mo mathvariant="italic">avg</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mtext mathvariant="italic">time</mml:mtext><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:mi>&#x003b3;</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mtext mathvariant="italic">wake</mml:mtext><mml:mo>_</mml:mo><mml:mtext mathvariant="italic">up</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The above formula can be used to compute the maximum average power (<italic>e<sub>max_avg</sub></italic>) from the average energy consumption rate (<italic>E<sub>time,i,j</sub></italic>), amount of data periodically handled by each node (<italic>&#x003b3;</italic>), and the <italic>wake-up</italic> energy required to switch from the <italic>idle mode</italic> or <italic>sleep mode</italic> for each node (<italic>E<sub>wake-up</sub></italic>).</p><p>The average energy required for transmitting and receiving data in the (<italic>i</italic>, <italic>j</italic>)-th ring (<italic>E<sub>time,i,j</sub></italic>) is computed as follows:
<disp-formula id="FD3"><label>(3)</label><mml:math id="mm3"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mtext mathvariant="italic">time</mml:mtext><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where the subscript <italic>Ft</italic> denotes the first tier, <italic>St</italic> denotes the second tier, (<italic>s</italic>) indicates transmitting, and (<italic>r</italic>) indicates receiving. In addition, the data transmitted from the <italic>x</italic>-th ring in the <italic>X</italic>-th tier (<italic>DS<sub>Xt(s),x</sub></italic>), energy consumption rate of the radio interface for transmission (<italic>P<sub>Xt(s),i</sub></italic>), and ring width of each tier (<italic>RA<sub>Xt,x</sub></italic>) are required.</p><p>The total energy consumption is obtained by multiplying the transmit and receive energies in each tier, and the average for each tier is the average of the values obtained by dividing the sum of the transmit and receive energies by the widths of the different rings.</p><p>Consider a network of radius <italic>L</italic> in where each tier has a constant number of rings <italic>k</italic> and the transmission and reception power are <italic>P<sub>Xs,x</sub></italic> and <italic>P<sub>Xr.x</sub></italic>, respectively. Then, it can be formulated as follows.</p><p>The data scale for transmitting and receiving is:
<disp-formula id="FD4"><label>(4)</label><mml:math id="mm4"><mml:mrow><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x022c5;</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></disp-formula></p><p>The power consumption of the radio interface is:
<disp-formula id="FD5"><label>(5)</label><mml:math id="mm5"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></disp-formula></p><p>The ring width is:
<disp-formula id="FD6"><label>(6)</label><mml:math id="mm6"><mml:mrow><mml:mi>R</mml:mi><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>X</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x022c5;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>Here <italic>a<sub>x</sub></italic>, <italic>b<sub>x</sub></italic>, and <italic>c<sub>x</sub></italic> are constants for the radio interface, <italic>R</italic> is the radius of the cluster, and <italic>L</italic> is given by <italic>(2k</italic> &#x02212; <italic>1)</italic>&#x000b7;<italic>R</italic>. Each tier can be formed by the same method. However, the first tier does not have the same clusters as those in the second tier. Therefore, we can write <italic>R</italic> = <italic>(2k</italic> &#x02212; <italic>1)</italic>&#x000b7;<italic>r</italic>.</p><p>The <italic>wake-up</italic> energy (<italic>E<sub>wake-up</sub></italic>) is the sum of the energies of all tiers, and it can be computed as follows:
<disp-formula id="FD7"><label>(7)</label><mml:math id="mm7"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mtext mathvariant="italic">wake</mml:mtext><mml:mo>-</mml:mo><mml:mtext mathvariant="italic">up</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mtext mathvariant="italic">all</mml:mtext></mml:mrow></mml:msub><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>F</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:msup><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <italic>N<sub>all</sub></italic> is the total number of sensor nodes (it is used to calculate the density of the first-tier sensors) and <italic>W<sub>Xt</sub></italic> is the energy consumed during wake-up. The wake-up energy consumption of each tier is obtained by dividing <italic>W<sub>Xt</sub></italic> by <italic>&#x003c0;L<sup>2</sup></italic> and <italic>&#x003c0;R<sup>2</sup></italic> for each cluster scale. In each tier, all nodes should wake up once for data transmission. Thus, the energy consumption is the same in all tiers of the network.</p></sec></sec><sec><label>4.</label><title>Performance Evaluation</title><p>In this paper, we assumed only one sink to compare the proposed method with existing methods (M-LEACH, HEED, and EEHC) by considering the clear parameters shown in <xref ref-type="table" rid="t1-sensors-12-14851">Table 1</xref>.</p><p>In the simulation, we used CC2420 [<xref ref-type="bibr" rid="b9-sensors-12-14851">9</xref>] for intracluster communication and IEEE 802.11g [<xref ref-type="bibr" rid="b10-sensors-12-14851">10</xref>] for intercluster communication on the basis of technical standards for fair performance evaluation, the technical standards are obtained from experimental measurements performed in past studies [<xref ref-type="bibr" rid="b6-sensors-12-14851">6</xref>&#x02013;<xref ref-type="bibr" rid="b8-sensors-12-14851">8</xref>].</p><p>The interface specifications are obtained by using the energy-consumption model of <xref rid="FD5" ref-type="disp-formula">Equation (5)</xref> in the simulation. The results of the performance evaluation are shown in <xref ref-type="fig" rid="f3-sensors-12-14851">Figure 3</xref>.</p><p>In <xref ref-type="fig" rid="f3-sensors-12-14851">Figure 3(a,b)</xref>, the maximum energy consumption rates for different hop counts are shown for each tier. The shaded areas are excluded since the transmission distance in these areas exceeds the maximum transmission distance, rendering them unsuitable for practical use. The results show that the lowest value of the maximum energy consumption rate corresponds to <italic>x<sub>Ft</sub></italic> and <italic>x<sub>St</sub></italic> values of 1 and 4, respectively; <italic>x<sub>Ft</sub></italic> and <italic>x<sub>St</sub></italic> are the energy-efficiency-optimized hop counts in the two tiers.</p><p><xref ref-type="fig" rid="f3-sensors-12-14851">Figure 3(c)</xref> compares the number of available nodes as different nodes run out of energy. The results show that our algorithm has 7%, 3%, and 4% more available nodes than M-LEACH, HEED, and EEHC, respectively. In particular, we see that while the existing methods have lower energy efficiency at lower hop counts, this is not the case with our method.</p><p><xref ref-type="fig" rid="f3-sensors-12-14851">Figure 3(d)</xref> compares the network lifespan for different numbers of nodes. For M-LEACH, we see that when the density of nodes increases with the number of nodes, the energy consumption of CHs increases. The increase in the energy consumption is because of clustering, which results from the large value of the absolute hop count. Consequently, the network lifespan decreases because of the energy consumption of CHs in relatively high-density areas. HEED and EEHC show relatively longer lifespans. However, the proposed method leads to about 17% greater lifespan.</p></sec><sec sec-type="conclusions"><label>5.</label><title>Conclusions</title><p>We propose a network model design method involving network approximation and an optimized multi-tiered clustering algorithm that maximizes node lifespan by minimizing energy consumption in a nonuniformly distributed network. Simulation results show that cluster scales and network parameters determined with the proposed method lead to more efficient performance compared to existing methods. Based on this research, therefore, we plan to devise methods to maintain uniform clusters in network environments with frequently changing topology.</p></sec></body><back><ack><p>This paper has been supported by the Software R&#x00026;D program of KCC (10914-06002, Development of global collaborative integrated security control system).</p></ack><ref-list><title>References</title><ref id="b1-sensors-12-14851"><label>1.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Starsinic</surname><given-names>M.</given-names></name></person-group><article-title>System Architecture Challenges in the Home M2M Network</article-title><conf-name>Proceedings of the IEEE Conference Long Island Systems Applications and Technology</conf-name><conf-loc>Farmingdale, NY, USA</conf-loc><conf-date>1&#x02013;7 May 2010</conf-date></element-citation></ref><ref id="b2-sensors-12-14851"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>M.</given-names></name><name><surname>Cao</surname><given-names>J.</given-names></name><name><surname>Chen</surname><given-names>G.</given-names></name><name><surname>Wang</surname><given-names>X.</given-names></name></person-group><article-title>An energy-aware routing protocol in wireless sensor networks</article-title><source>Sensors</source><year>2009</year><volume>9</volume><fpage>445</fpage><lpage>462</lpage><pub-id pub-id-type="pmid">22389610</pub-id></element-citation></ref><ref id="b3-sensors-12-14851"><label>3.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Handy</surname><given-names>M.J.</given-names></name><name><surname>Haase</surname><given-names>M.</given-names></name><name><surname>Timmermann</surname><given-names>D.</given-names></name></person-group><article-title>Low Energy Adaptive Clustering Hierarchy with Deterministic Cluster-Head Selection</article-title><conf-name>Proceedings of the 4th International Workshop on Mobile and Wireless Communications Network</conf-name><conf-loc>Stockholm, Sweden</conf-loc><conf-date>9&#x02013;11 September 2002</conf-date><fpage>368</fpage><lpage>372</lpage></element-citation></ref><ref id="b4-sensors-12-14851"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lindsey</surname><given-names>S.</given-names></name><name><surname>Raghavendra</surname><given-names>C.S.</given-names></name></person-group><article-title>PEGASIS: Power-efficient gathering in sensor information systems</article-title><source>IEEE Conf. Aero.</source><year>2002</year><volume>3</volume><fpage>1125</fpage><lpage>1130</lpage></element-citation></ref><ref id="b5-sensors-12-14851"><label>5.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Manjeshwar</surname><given-names>A.</given-names></name><name><surname>Agrawal</surname><given-names>D.P.</given-names></name></person-group><article-title>TEEN: A Routing Protocol for Enhanced Efficiency in Wireless Sensor Networks</article-title><conf-name>Proceedings of the IEEE International Parallel and Distributed Processing Symposium</conf-name><conf-loc>San Francisco, CA, USA</conf-loc><conf-date>23&#x02013;27 April 2001</conf-date></element-citation></ref><ref id="b6-sensors-12-14851"><label>6.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Abuhelaleh</surname><given-names>M.</given-names></name><name><surname>Mismar</surname><given-names>T.</given-names></name><name><surname>Abuzneid</surname><given-names>A.</given-names></name></person-group><article-title>Armor-LEACH&#x02014;Energy Efficient, Secure Wireless Networks Communication</article-title><conf-name>Proceedings of the IEEE International Conference on Computer Communications and Networks</conf-name><conf-loc>St. Thomas, VI, USA</conf-loc><conf-date>3&#x02013;7 August 2008</conf-date><fpage>1</fpage><lpage>7</lpage></element-citation></ref><ref id="b7-sensors-12-14851"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Younis</surname><given-names>O.</given-names></name><name><surname>Fahmy</surname><given-names>S.</given-names></name></person-group><article-title>HEED: A hybrid, energy-efficient, distributed clustering approach for <italic>ad hoc</italic> sensor networks</article-title><source>IEEE Trans. Mobile Comput.</source><year>2004</year><volume>3</volume><fpage>366</fpage><lpage>379</lpage></element-citation></ref><ref id="b8-sensors-12-14851"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kumar</surname><given-names>D.</given-names></name><name><surname>Aseri</surname><given-names>T.C.</given-names></name><name><surname>Patel</surname><given-names>R.B.</given-names></name></person-group><article-title>EEHC: Energy efficient heterogeneous clustered method for wireless sensor networks</article-title><source>Comput. Commun.</source><year>2009</year><volume>32</volume><fpage>662</fpage><lpage>667</lpage></element-citation></ref><ref id="b9-sensors-12-14851"><label>9.</label><element-citation publication-type="webpage"><article-title>Propagation Data and Prediction Methods for the Planning of Short-range Out-door Radio Communications Systems and Radio Local Area Network in the Frequency Range 300 MHz to 100 GHz</article-title><comment>Available online: <ext-link ext-link-type="uri" xlink:href="http://webs.uvigo.es/servicios/biblioteca/uit/rec/P/R-REC-P.1411-4-200708-I!!PDF-E.pdf">http://webs.uvigo.es/servicios/biblioteca/uit/rec/P/R-REC-P.1411-4-200708-I!!PDF-E.pdf</ext-link> (accessed on 30 August 2012)</comment></element-citation></ref><ref id="b10-sensors-12-14851"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vassis</surname><given-names>D.</given-names></name><name><surname>Kormentzas</surname><given-names>G.</given-names></name><name><surname>Rouskas</surname><given-names>A.</given-names></name></person-group><article-title>The IEEE 802.11g standard for high data rate WLANs</article-title><source>IEEE Network</source><year>2005</year><volume>19</volume><fpage>21</fpage><lpage>26</lpage></element-citation></ref></ref-list></back><floats-group><fig id="f1-sensors-12-14851" position="float"><label>Figure 1.</label><caption><p>Hierarchical uniform cluster formation. (<bold>a</bold>) Non-uniform network environment. (<bold>b</bold>) Cluster formation in Low-Density Area. (<bold>c</bold>) Cluster formation in High-Density Area. (<bold>d</bold>) Hierarchical cluster formation using the shortest-hop-count-based clustering.</p></caption><graphic xlink:href="sensors-12-14851f1"/></fig><fig id="f2-sensors-12-14851" position="float"><label>Figure 2.</label><caption><p>Network approximation model.</p></caption><graphic xlink:href="sensors-12-14851f2"/></fig><fig id="f3-sensors-12-14851" position="float"><label>Figure 3.</label><caption><p>Performance evaluation. (<bold>a</bold>) First-tier standpoint; (<bold>b</bold>) Second-tier standpoint; (<bold>c</bold>) Average service rate comparison; (<bold>d</bold>) Network lifespan comparison.</p></caption><graphic xlink:href="sensors-12-14851f3"/></fig><table-wrap id="t1-sensors-12-14851" position="float"><label>Table 1.</label><caption><p>Simulation parameters.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" rowspan="1" colspan="1"><bold>Description</bold></th><th align="center" valign="top" rowspan="1" colspan="1"><bold>Value</bold></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">Network size</td><td align="center" valign="top" rowspan="1" colspan="1">500 m/L</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Number of nodes</td><td align="center" valign="top" rowspan="1" colspan="1">5,000</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Data aggregation energy</td><td align="center" valign="top" rowspan="1" colspan="1">5 nJ/bit/report</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Initial energy</td><td align="center" valign="top" rowspan="1" colspan="1">2.5 J</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Energy consumed for short distance transmission</td><td align="center" valign="top" rowspan="1" colspan="1">10 pJ/bit</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Energy consumed for long distance transmission</td><td align="center" valign="top" rowspan="1" colspan="1">0.0015 pJ/bit</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Energy consumed to send or receive a signal</td><td align="center" valign="top" rowspan="1" colspan="1">50 nJ/bit</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Wake-up energy (CC2420 for 1st tier)</td><td align="center" valign="top" rowspan="1" colspan="1">0.0347 mJ</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Wake-up energy (IEEE 802.11g for 2nd tier)</td><td align="center" valign="top" rowspan="1" colspan="1">5 mJ</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Maximum transmission distance (CC2420)</td><td align="center" valign="top" rowspan="1" colspan="1">60 m</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Maximum transmission distance (IEEE 802.11 g)</td><td align="center" valign="top" rowspan="1" colspan="1">100 m</td></tr></tbody></table></table-wrap></floats-group></article>