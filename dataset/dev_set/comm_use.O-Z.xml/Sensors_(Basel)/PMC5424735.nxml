<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">28420102</article-id><article-id pub-id-type="pmc">5424735</article-id><article-id pub-id-type="doi">10.3390/s17040858</article-id><article-id pub-id-type="publisher-id">sensors-17-00858</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Efficient Actor Recovery Paradigm for Wireless Sensor and Actor Networks</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Mahjoub</surname><given-names>Reem K.</given-names></name></contrib><contrib contrib-type="author"><name><surname>Elleithy</surname><given-names>Khaled</given-names></name><xref rid="c1-sensors-17-00858" ref-type="corresp">*</xref></contrib></contrib-group><contrib-group><contrib contrib-type="editor"><name><surname>Reindl</surname><given-names>Leonhard M.</given-names></name><role>Academic Editor</role></contrib></contrib-group><aff id="af1-sensors-17-00858">Department of Computer Science, University of Bridgeport, 126 Park Avenue, Bridgeport, CT 06604, USA; <email>rmahjoub@my.bridgeport.edu</email></aff><author-notes><corresp id="c1-sensors-17-00858"><label>*</label>Correspondence: <email>elleithy@bridgeport.edu</email>; Tel.: +1-202-576-4703</corresp></author-notes><pub-date pub-type="epub"><day>14</day><month>4</month><year>2017</year></pub-date><pub-date pub-type="collection"><month>4</month><year>2017</year></pub-date><volume>17</volume><issue>4</issue><elocation-id>858</elocation-id><history><date date-type="received"><day>24</day><month>12</month><year>2016</year></date><date date-type="accepted"><day>10</day><month>4</month><year>2017</year></date></history><permissions><copyright-statement>&#x000a9; 2017 by the authors.</copyright-statement><copyright-year>2017</copyright-year><license license-type="open-access"><license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>The actor nodes are the spine of wireless sensor and actor networks (WSANs) that collaborate to perform a specific task in an unverified and uneven environment. Thus, there is a possibility of high failure rate in such unfriendly scenarios due to several factors such as power consumption of devices, electronic circuit failure, software errors in nodes or physical impairment of the actor nodes and inter-actor connectivity problem. Therefore, it is extremely important to discover the failure of a cut-vertex actor and network-disjoint in order to improve the Quality-of-Service (QoS). In this paper, we propose an Efficient Actor Recovery (EAR) paradigm to guarantee the contention-free traffic-forwarding capacity. The EAR paradigm consists of a Node Monitoring and Critical Node Detection (NMCND) algorithm that monitors the activities of the nodes to determine the critical node. In addition, it replaces the critical node with backup node prior to complete node-failure which helps balancing the network performance. The packets are handled using Network Integration and Message Forwarding (NIMF) algorithm that determines the source of forwarding the packets; either from actor or sensor. This decision-making capability of the algorithm controls the packet forwarding rate to maintain the network for a longer time. Furthermore, for handling the proper routing strategy, Priority-Based Routing for Node Failure Avoidance (PRNFA) algorithm is deployed to decide the priority of the packets to be forwarded based on the significance of information available in the packet. To validate the effectiveness of the proposed EAR paradigm, the proposed algorithms were tested using OMNET++ simulation.</p></abstract><kwd-group><kwd>wireless sensor network</kwd><kwd>wireless sensor actor network</kwd><kwd>WSN</kwd><kwd>WSAN</kwd><kwd>RSSI</kwd><kwd>latency</kwd><kwd>actor</kwd><kwd>sensor</kwd><kwd>node failure</kwd><kwd>data recovery</kwd></kwd-group></article-meta></front><body><sec id="sec1-sensors-17-00858"><title>1. Introduction</title><p>Wireless Sensor and Actor Networks collaborate to transmit and process information in order to perform specific tasks. WSANs comprise sensors, actors, and a base station [<xref rid="B1-sensors-17-00858" ref-type="bibr">1</xref>] as shown in <xref ref-type="fig" rid="sensors-17-00858-f001">Figure 1</xref>. The sensors are responsible for sensing and transmitting the events to the actor node. In response, the actors collect, process, transmit and utilize the data, due to their high performance capability and power properties [<xref rid="B2-sensors-17-00858" ref-type="bibr">2</xref>,<xref rid="B3-sensors-17-00858" ref-type="bibr">3</xref>]. The communication in WSANs can be classified as: (i) sensor-actor (SA) communication; (ii) actor-actor (AA) communication; (iii) actor-sink (AS) communication and (iv) sensor to sensor (SS) communication. WSANs can further be classified into semi-automated or automated WSANs. In semi-automated WSANs, sensor nodes sense the events and forward the data to the sink node, while the sink node forward the sensed data to the proper actor in-order perform the specific action. WSANs are potentially suitable for several applications including transportation, battlefield surveillance, industry, health, environmental monitoring, smart energy grids, cloud computing, and nuclear fields. WSANs performance is affected by several factors, such as energy efficiency, transmission media, scalability, and node density. The selection of the parameters for optimization depends on the nature of the application. WSANs have an edge over the traditional Wireless Sensor Networks (WSNs) due to the high energy and low power consumption characteristics.</p><p>In WSANs, the actor nodes possess sophisticated features that increase the power capability and network usage. Thus, maintaining the inter-actor connectivity is indispensable in WSANs. The failure of an actor may cause loss of communication or a network disconnect. Thus, actors must communicate with each other to guarantee the entire network coverage and to harmonize their actions for the best response. In case of actor failure, adjacent actors should restore the process or they may be replaced by a backup actor. This solution, however, could be costly and infeasible. Alternatively, the actor can be replaced by one of its neighbor actors. Distributed localization algorithms are used to handle these situations. In this case, &#x0201c;hello&#x0201d; messages are exchanged by the neighbor actors in distributed localization algorithms despite the limitation of the network resources. Furthermore, the nodes can compute their distances and positions by exchanging the information carried in these messages. The distributed localization techniques are used for calculating the distance between the nodes, identifying the physical locations of actor nodes, reallocating the locations, and salvage of sensor or actor node failure.</p><p>Received Signal Strength Indicator (RSSI) is a range base localization technique that is applicable for determining the received signal strength including the distance between the sender and the receiver nodes. At the receiver side, RSSI technique is used to measure the signal strength [<xref rid="B4-sensors-17-00858" ref-type="bibr">4</xref>]. Higher levels of RSSI indicate stronger signals. Some localization approaches utilize the RSSI for nodes distance measurement. In WSANs, most of the node localization and routing approaches depend on the hop count information rather than table-based routing protocols. With these motivations, this study introduces a mathematical model for determining actor forwarding capacity in WSAN using RSSI message information. The model aims at guaranteeing contention-free forwarding capacity. The paper also contributes to the literature by providing the best RSSI value to improve the traffic forwarding process. State-of-the-art research is used to provide the best node failure recovery process to extend the network lifetime. A tradeoff between the QoS improvement and reduction in the power consumption is considered.</p><p>The paper introduces three novel algorithms and optimized low latency deterministic model based on RSSI. First, Node Monitoring and Critical Node Detection algorithm checks the entire network to determine the critical node before it fails which greatly improves and balances the network performance; Second, Network Integration and Message Forwarding algorithm mostly focuses on improving the QoS by handling the packet forwarding process that has the capacity to decide the source of the forwarding packet (either from sensor node or actor node). As, this algorithm introduces much easier process to deal with packet forwarding flow. In addition, accurate packet forwarding process reduces the latency and bandwidth consumption; Third, Priority-Based Routing for Node Failure Avoidance algorithm determines the significant information available in each forwarding packet. Based on the nature of the information, the packets are routed to the next node. As, this algorithm particularly handles the redundant data prior to routing the packets; Finally, optimized RSSI model is introduced that selects the different power strengths for each beacon in order to ensure the proper delivery of the beacon to each node. This aims to reduce the latency and estimating the prediction of the node energy-level. As a result, QoS provisioning is maintained while extending the network lifetime.</p></sec><sec id="sec2-sensors-17-00858"><title>2. Contribution and Paper Organization</title><p>The main difference between WSAN and WSN is the existence of actor nodes. Actor nodes add major enhancements and robustness to the sensor network. In WSNs detection, processing and handling are usually done using sensor nodes which make those node subject to failure and degrades the network performance, while in WSANs, sensor nodes detect events and forward their information to actor nodes. Then, the actor nodes handle the processing of information, decision making and event handling. Thus, the actor node is a major component of WSAN. The failure of an actor node can degrade the overall network performance. Furthermore, the failure of an actor node may result in a partitioning of the WSAN and may limit event detection and handling. In this paper, a new method is proposed for efficient actor recovery paradigm (EAR) which guarantees the contention-free traffic-forwarding capacity. Unlike previous studies, EAR aims to provide efficient failure detection and recovery mechanism while maintaining the Quality of service. Thus, the proposed paradigm contributes three novel algorithms and optimized low latency deterministic model based on RSSI work as follows: <list list-type="bullet"><list-item><p>Node Monitoring and Critical Node Detection (NMCND) algorithm that monitors the activities of the nodes to determine the nodes types and distinguish critical nodes. The NMCND algorithm checks the entire network to determine the critical node during the network life time and pre-assign a backup node for each critical node; so in case the failure of critical node, this node takes place in order to improve and balances the network performance.</p></list-item><list-item><p>Optimized RSSI model is introduced that selects the different power strengths for each beacon in order to ensure the proper delivery of the beacon to each node. This aims to reduce the latency and estimating the prediction of the node energy-level. As a result, QoS provisioning is maintained and extended the network lifetime.</p></list-item><list-item><p>Network Integration and Message Forwarding (NIMF) improves the QoS by handling the packet forwarding process. NIMF works to reduce packet forwarding through critical nodes and enhances network lifetime. Moreover, NIMF has the capability to decide the source of the forwarded packet which enhances the packet forwarding flow. Thus, accurate packet forwarding process reduces the latency and bandwidth consumption.</p></list-item><list-item><p>Priority-Based Routing for Node Failure Avoidance algorithm (PRNFA) handles the routing process. PRNFA analyzes and evaluates the information of the packet in order to route it to the next node. It determines the priority of the forwarded packets. In addition, PRNFA eliminates redundant data prior to routing the packets.</p></list-item></list></p><p>The remainder of the paper is organized as follows: <xref ref-type="sec" rid="sec3-sensors-17-00858">Section 3</xref> presents a comprehensive review of relevant literature. <xref ref-type="sec" rid="sec4-sensors-17-00858">Section 4</xref> formulates the problem and provides details of the optimized deterministic actor recovery system model. <xref ref-type="sec" rid="sec5-sensors-17-00858">Section 5</xref> provides the simulation setup and presents the analysis of our findings. Finally, the summary of the paper is provided by the conclusions in <xref ref-type="sec" rid="sec5-sensors-17-00858">Section 5</xref>.</p></sec><sec id="sec3-sensors-17-00858"><title>3. Related Work</title><p>In this section, the salient features of relevant related approaches are discussed. WSANs are difficult to deploy, even though WSANs are known to improve the overall network performance. One shortcoming of WSANs is that these networks adversely are affected by inadequate positioning, power restraints, and routing limitations. To avoid these issues, the sensor and actor nodes should be deployed randomly or at fixed position based on the application requirements. Actor nodes can either be mobile or static. Hence, the node mobility improves the network performance metrics such as coverage, connectivity and lifetime [<xref rid="B5-sensors-17-00858" ref-type="bibr">5</xref>]. A number of localization techniques were studied and introduced for WSANs. Some techniques focus on nodes positioning are provided in [<xref rid="B6-sensors-17-00858" ref-type="bibr">6</xref>], while some other studies focus on failure node recovery process [<xref rid="B7-sensors-17-00858" ref-type="bibr">7</xref>,<xref rid="B8-sensors-17-00858" ref-type="bibr">8</xref>,<xref rid="B9-sensors-17-00858" ref-type="bibr">9</xref>,<xref rid="B10-sensors-17-00858" ref-type="bibr">10</xref>,<xref rid="B11-sensors-17-00858" ref-type="bibr">11</xref>,<xref rid="B12-sensors-17-00858" ref-type="bibr">12</xref>,<xref rid="B13-sensors-17-00858" ref-type="bibr">13</xref>,<xref rid="B14-sensors-17-00858" ref-type="bibr">14</xref>,<xref rid="B15-sensors-17-00858" ref-type="bibr">15</xref>].</p><p>WSANs are mainly deployed in harsh areas, and are supposed to support long network lifetime. As we mentioned earlier, actor nodes are very essential nodes in WSAN. Thus, it is essential for WSAN algorithms to support not only actor node deployment and actor mobility, but they should be robust enough to provide failure detection and self-healing network recovery.</p><p>Some works presented in the literature manage to handle the actor node deployment and mobility [<xref rid="B16-sensors-17-00858" ref-type="bibr">16</xref>,<xref rid="B17-sensors-17-00858" ref-type="bibr">17</xref>,<xref rid="B18-sensors-17-00858" ref-type="bibr">18</xref>,<xref rid="B19-sensors-17-00858" ref-type="bibr">19</xref>,<xref rid="B20-sensors-17-00858" ref-type="bibr">20</xref>,<xref rid="B21-sensors-17-00858" ref-type="bibr">21</xref>,<xref rid="B22-sensors-17-00858" ref-type="bibr">22</xref>,<xref rid="B23-sensors-17-00858" ref-type="bibr">23</xref>]. Nevertheless, they do not provide solutions in the case of the occurrence of actor node failure. The study in [<xref rid="B20-sensors-17-00858" ref-type="bibr">20</xref>] presents a framework for real-time data report and task execution (RTRE) which aims to achieve event assignment through multi-actor coordination and data collected coordination between sensor and actors real-time sensor-actuator data collection. The authors of [<xref rid="B23-sensors-17-00858" ref-type="bibr">23</xref>] present a self-organizing mobility control in WSANs based on virtual electrostatic interactions which aim to enhance actor node deployment and control actors&#x02019; mobility. The main purpose of the previously mentioned techniques is to manage actor mobility during deployment or during event handling. Meanwhile, actor mobility features may cause continuous changes to the network topology. Thus, an actor may go outside a specific region range and is then defined as failed.</p><p>In WSANs, actor failure can be due to their limited power, mobility, or topology changes. The mobility feature can cause actors to go outside the communication range. Moreover, network topology may be affected by such behavior. Effective topology management techniques should be implemented. Several proposed mechanisms where introduced in order to manage network failure concerning topology management [<xref rid="B5-sensors-17-00858" ref-type="bibr">5</xref>,<xref rid="B11-sensors-17-00858" ref-type="bibr">11</xref>,<xref rid="B13-sensors-17-00858" ref-type="bibr">13</xref>,<xref rid="B24-sensors-17-00858" ref-type="bibr">24</xref>,<xref rid="B25-sensors-17-00858" ref-type="bibr">25</xref>,<xref rid="B26-sensors-17-00858" ref-type="bibr">26</xref>,<xref rid="B27-sensors-17-00858" ref-type="bibr">27</xref>,<xref rid="B28-sensors-17-00858" ref-type="bibr">28</xref>,<xref rid="B29-sensors-17-00858" ref-type="bibr">29</xref>,<xref rid="B30-sensors-17-00858" ref-type="bibr">30</xref>,<xref rid="B31-sensors-17-00858" ref-type="bibr">31</xref>,<xref rid="B32-sensors-17-00858" ref-type="bibr">32</xref>].</p><p>Fault detection mechanisms are classified into proactive and reactive methods. In proactive methods, fault and restoration mechanisms are addressed during the network setup. Some mechanisms implement fault tolerance topologies in the network setup while others use redundant and backup nodes to ensure fault tolerance [<xref rid="B33-sensors-17-00858" ref-type="bibr">33</xref>]. On the other hand, a reactive scheme pursues to utilize the network resources and performs recovery through node repositioning. Reactive schemes require network monitoring in order to maintain node status. Network status, recovery algorithms, and recovery scope are important factors in reactive schemes. Reactive recovery algorithms are classified into centralized algorithms or distributed algorithm and have been widely used in the literature [<xref rid="B26-sensors-17-00858" ref-type="bibr">26</xref>,<xref rid="B29-sensors-17-00858" ref-type="bibr">29</xref>,<xref rid="B30-sensors-17-00858" ref-type="bibr">30</xref>,<xref rid="B32-sensors-17-00858" ref-type="bibr">32</xref>,<xref rid="B33-sensors-17-00858" ref-type="bibr">33</xref>,<xref rid="B34-sensors-17-00858" ref-type="bibr">34</xref>,<xref rid="B35-sensors-17-00858" ref-type="bibr">35</xref>,<xref rid="B36-sensors-17-00858" ref-type="bibr">36</xref>,<xref rid="B37-sensors-17-00858" ref-type="bibr">37</xref>,<xref rid="B38-sensors-17-00858" ref-type="bibr">38</xref>]. Scope of recovery refers to how many nodes are involved in the recovery. Some mechanisms require a single node [<xref rid="B35-sensors-17-00858" ref-type="bibr">35</xref>,<xref rid="B36-sensors-17-00858" ref-type="bibr">36</xref>] while others identify a block of nodes for the recovery process [<xref rid="B10-sensors-17-00858" ref-type="bibr">10</xref>,<xref rid="B39-sensors-17-00858" ref-type="bibr">39</xref>].</p><p>Moreover, actor fault impact can vary depending on the node&#x02019;s importance and type. Some fault management detection and recovery procedures classify the actor nodes into critical nodes and non-critical nodes [<xref rid="B10-sensors-17-00858" ref-type="bibr">10</xref>,<xref rid="B24-sensors-17-00858" ref-type="bibr">24</xref>,<xref rid="B37-sensors-17-00858" ref-type="bibr">37</xref>]. A critical node refers to a node which failure causes network partitioning. Most algorithms define the critical nodes using 2-hop message exchange information [<xref rid="B8-sensors-17-00858" ref-type="bibr">8</xref>,<xref rid="B36-sensors-17-00858" ref-type="bibr">36</xref>]. On the other hand, a study conducted by Imran et al. [<xref rid="B40-sensors-17-00858" ref-type="bibr">40</xref>], used 1-hop message exchange to identify the critical actors. This is performed by calculating the distance from the actor to its adjacent nodes. If the distance is less than the neighbor&#x02019;s communication range, the actor is defined as non-critical; otherwise, the actor is defined as critical.</p><p>The Distributed Recovery from Network Partitioning in Movable (DRNPM) [<xref rid="B40-sensors-17-00858" ref-type="bibr">40</xref>] and Actor Positioning with Minimal Movement (APMM) [<xref rid="B7-sensors-17-00858" ref-type="bibr">7</xref>], in Wireless Sensor and Actor Networks approaches were introduced for node recovery. These studies applied pre-assigned backup procedures to recover the actor node failure. However, the approaches fall short in addressing the energy efficiency during backup node selection.</p><p>In [<xref rid="B35-sensors-17-00858" ref-type="bibr">35</xref>] a two-hop actor node failure recovery algorithm is introduced in which, an adjacent actor and best candidate are selected to handle the failure node. However, this approach suffers due to the overhead. Haider et al. [<xref rid="B36-sensors-17-00858" ref-type="bibr">36</xref>] introduced Nearest Non-critical Neighbor (NNN) algorithm that attempts to achieve inter-actor connectivity caused by network splitting. The proposed algorithm uses a localized and distributed approach. When the neighbors of a critical actor detect the failed actor, they initiate the reinstatement process. This process consists of the replacement of the critical node with the nearest non-critical actor to control any further splitting overhead. The overhead may occur when a critical actor movement is selected for node replacement. Distinguishing between critical and non-critical actor nodes favors the NNN procedure to have slighter recovery scope in comparison to [<xref rid="B35-sensors-17-00858" ref-type="bibr">35</xref>]. However, the network is adversely affected due to spilt transposition overhead. A new energy efficient recovery method for recovery of lost connectivity (RLC) based on two-point crossover genetic algorithm (GA) is proposed to reconnect the partitioned network to discover the actor node failure process [<xref rid="B41-sensors-17-00858" ref-type="bibr">41</xref>].</p><p>A study that handles the tolerating simultaneous failures (TSF) in WSANs is proposed by [<xref rid="B42-sensors-17-00858" ref-type="bibr">42</xref>]. In this study, TSF is based on the ranking of the network nodes pertinent to a pre-assigned root actor. Ranking uses a tree that helps the coordination process among the nodes. The nodes are virtually grouped in order to minimize the recovery overhead. Cluster-based node failure algorithms were proposed by [<xref rid="B43-sensors-17-00858" ref-type="bibr">43</xref>,<xref rid="B44-sensors-17-00858" ref-type="bibr">44</xref>] that are based on 1-hop node failure recovery process.</p><p>Furthermore, the route duration improvement (RDI) algorithm based on decision tree is incorporated in the reactive routing protocol to support WSANs [<xref rid="B45-sensors-17-00858" ref-type="bibr">45</xref>]. This aims to select the most long-lived routers. The decision tree supports the node mobility. The improved flooding control is used to improve the route performance and reduce the overheads, whereas, power consumption caused by control packets is not handled.</p><p>Similarly, recovering from node failure (RNF) based on the Least-Disruptive Topology Repair (LeDiR) algorithm is used to handle actor failure/recovery. The RNF handles the autonomous transposition for the subset of the actor nodes to restore connectivity [<xref rid="B10-sensors-17-00858" ref-type="bibr">10</xref>]. The LeDiR algorithm depends on the local view of the actor node to develop a recovery plan that rearranges the least number of nodes and confirms that no path between any pair of nodes is protracted. In addition, LeDiR attempts to detect and manage cut-vertex node failure and perform recovery using path discovery and routing information. In the case of node failure in LeDiR, neighboring nodes will re-compute their routing tables and drive their enrollment decisions for the recovery process. In response to the failure of a critical node, the neighbor containing the smallest block replaces this node. LeDiR assumes that each node calculates the shortest path to every other node and stores this information in its routing table. In case node failure occurs, the 1-hop neighbors identify if the node is critical or non-critical using the shortest path routing table. Then, the smallest block is identified. Within the smallest block, a neighbor of a failed node is chosen as the candidate node (CN) to replace the failed node. If more than one neighbor node is part of the smallest block, the neighbor nearest the failed actor is chosen to manage the block movement. The RNF aims to control existing route discovery activities in the network and enforce no extra pre-failure communication overhead. However, RNF consumes an additional power. Moreover, large number of nodes are involved in the recovery process which leads to more topology changes; thus, network is subject to extended failure causing a cascade recovery.</p><p>Grid-based approaches are introduced in many WSANs. As one of the interesting grid-based approaches, an actor-supported repositioning approach supports the single static actor. Each grid consists of single static actor, in addition to several sensor nodes that sense the events. Static actors are responsible to obtain the information of sensors location along with grid information. Hence, the grid information collects the region information. Once an event occurs, the sensors nodes forward sensed data to the static actor node. The overhead of the approach increases when using single static actor node for multiple grid region monitoring [<xref rid="B46-sensors-17-00858" ref-type="bibr">46</xref>]. This problem surges when multiple reporting regions instantaneously report to the same static node [<xref rid="B14-sensors-17-00858" ref-type="bibr">14</xref>,<xref rid="B30-sensors-17-00858" ref-type="bibr">30</xref>,<xref rid="B47-sensors-17-00858" ref-type="bibr">47</xref>,<xref rid="B48-sensors-17-00858" ref-type="bibr">48</xref>,<xref rid="B49-sensors-17-00858" ref-type="bibr">49</xref>].</p><p>The distributed prioritized connectivity restoration algorithm (DPCRA) [<xref rid="B11-sensors-17-00858" ref-type="bibr">11</xref>] is introduced to cover the partitions and reinstate the node connectivity by using small number of nodes. The algorithm aims to identify the negative effect of the actor on the partitions. Repairing processes are done locally while storing minimum information in each node. The main focus of the work is to use multiple backup nodes for the partitioned recovery. Nevertheless, the algorithm fails to address backup node selection criteria which leads that those nodes may have higher probability of failure. Thus, this can affect the overall network performance, especially energy consumption, which leads to higher probability of node failure throughout the network.</p><p>The actor critical recovery (ACR) algorithm is proposed for efficient resource utilization [<xref rid="B7-sensors-17-00858" ref-type="bibr">7</xref>]. The algorithm aims to minimize the delay and determine the primary backup node to satisfy application requirement. In this study, Akkaya et al. proposed the Distributed Partition Detection and Recovery algorithm (DPDR) to handle cut-vertex node failure recovery. The main objective of the work is to minimize node movement distance during the recovery process. Cut-vertex node determination is done using Depth First Search (DFS). DPDR assigns a failure handler (FH) node for each cut-vertex. FH is responsible for the network recovery when the cut-vertex failure occur. FH chooses to replace the failed node with the node which has the closet distance to the failed node. The main drawbacks of DPDR are the involved communication and calculation overheads, and FH recovery assignment criteria.</p><p>The Advanced-self-healing Connectivity Recovery Algorithm (ACRA) is introduced to recover failed actors. The ACRA determines the nature of the actor whether it is a cut vertex or node-connectivity actor [<xref rid="B13-sensors-17-00858" ref-type="bibr">13</xref>]. This approach applies a depth-first search algorithm to determine the nature of the actor. For handling suddenly failed nodes, the minimal block backup nodes are used until the network is restored. The actor node with high transmission power and higher coverage area is selected and connectivity is recovered. This type of process consumes more energy since cluster head and actor node has to be selected in case of their absence in the network. The algorithm is based on two point crossover Genetic Algorithm (GA) to reconnect the partitioned network. Sensor and actor nodes are scattered randomly in the area of interest and form clusters. In this network, all the nodes are equipped with a failure detection system and are able to detect the failure of cut-vertex actor nodes by using the shared stored information of their 1-hop neighbors. Whenever a cut-vertex failure is detected, the neighbor CHs broadcast Recovery messages to all their neighboring nodes toward the sink node until the next actor node or the next CH is found for lost connectivity. Recovery Phase is executed by finding a stable sensor with high transmission power and higher coverage. The stable sensor CHs (as per the GA-based criterion) among their neighbor nodes is the bridging router for connecting the disjoint network. Even though actor nodes include higher transmission power, the process still consumes more energy; the algorithm consumes energy because of the use of clustering. Moreover, sensor involvement in the recovery process impacts the overall network lifetime and performance due to the sensors&#x02019; limitations.</p><p>The Partitioning detection and Connectivity Restoration (PCR) algorithm is introduced to endure critical actor failure [<xref rid="B50-sensors-17-00858" ref-type="bibr">50</xref>]. The PCR regulates critical/non-critical actors using localized information and replaces each critical node with a suitable backup. The pre-designated backup process determines the failure if it is primary actor node and starts the post-failure recovery process that includes coordinated multi-actor relocation. The author constructed the formal specification of PCR using Z notation. An update of the selection of the actor&#x02019;s polling points is proposed in [<xref rid="B51-sensors-17-00858" ref-type="bibr">51</xref>]. The update selection process involves the residual energy and the locations of the nodes. The approach dynamically generates the multi-hop routing trees used by the polling points in order to balance energy consumption of the node to prolong the network lifetime. However, the paper focused on sensor nodes and also did not address the actual node failure recovery process.</p><p>All existing approaches either attempt to recover the failure actor or try to reduce the overhead [<xref rid="B8-sensors-17-00858" ref-type="bibr">8</xref>,<xref rid="B9-sensors-17-00858" ref-type="bibr">9</xref>,<xref rid="B30-sensors-17-00858" ref-type="bibr">30</xref>,<xref rid="B31-sensors-17-00858" ref-type="bibr">31</xref>,<xref rid="B32-sensors-17-00858" ref-type="bibr">32</xref>,<xref rid="B33-sensors-17-00858" ref-type="bibr">33</xref>,<xref rid="B34-sensors-17-00858" ref-type="bibr">34</xref>,<xref rid="B35-sensors-17-00858" ref-type="bibr">35</xref>,<xref rid="B38-sensors-17-00858" ref-type="bibr">38</xref>,<xref rid="B52-sensors-17-00858" ref-type="bibr">52</xref>,<xref rid="B53-sensors-17-00858" ref-type="bibr">53</xref>,<xref rid="B54-sensors-17-00858" ref-type="bibr">54</xref>]. We conclude that existing approaches have attempted to replace the critical node with another backup node, but they fail to maintain the QoS parameters and energy consumption. For guaranteeing QoS in our EAR proposed algorithm, the Node Monitoring and Critical Node Detection algorithm (NMCND) monitors the activities of the nodes to determine the nodes&#x02019; types to distinguish critical nodes. Additionally, our proposed approach not only determines the critical nodes, but handles the packet forwarding process when a primary node fails. To handle packet forwarding, the Network Integration and Message Forwarding (NIMF) algorithm is introduced. In addition, the Process-Based Routing for Node Failure Avoidance algorithm (PRNFA) is developed to handle the routing process and to eliminate routing process of the redundant packets to other nodes in order to avoid the network congestion and reducing the latency. Therefore, the goal of this work is to improve the recovery node process while maintaining the QoS provisioning and power efficiency.</p></sec><sec id="sec4-sensors-17-00858"><title>4. Problem Statement and Optimized Deterministic Actor Recovery System Model</title><sec id="sec4dot1-sensors-17-00858"><title>4.1. Problem Formulation</title><p>WSANs comprise actors with powerful resources and sensor nodes with limited computation, power, and communication capabilities. The sensors and actors in WSANs collaborate together to monitor and respond to the surrounding world. WSANs can be applied to a wide range of applications, like health or environmental monitoring, chemical attack detection, battlefield surveillance, space missions, intrusion detection, etc. However, WSANs are greatly affected due to environmental changes, frequent changes in event-detection and actor failure processes. The failure of an actor node can result in partitioning of the WSAN and may limit event detection and handling. Actors may fail due to hardware failure, attacks, energy depletion, or communication link issues. Sensor node failure may cause loss of event detection of the assigned environment covered by the sensor. The probability of the actor failure is less than that of sensor failure and can be controlled through the relocation of mobile nodes due to their powerful characteristics; however, actor failure can cause more damage than sensor failure. Actor failure can cause a loss of coordination and connectivity between nodes, limitation in event handling, and can lead to a disjoint WSAN.</p><p>The actor failure occurrence is very critical as it degrades the network performance. The failure of a critical actor may cause high impact to the whole network. Critical actor nodes refer to actors which their failure cause network partitioning. <xref ref-type="fig" rid="sensors-17-00858-f002">Figure 2</xref> illustrates the concept of critical actor nodes. Assume that actor A3 failed. Its failure will cause the network to disjoint. Thus, A3 is a critical node. Actor nodes A2, A6, and A7 are critical nodes as well.</p><p>Most of the existing approaches attempted to replace the critical node with another backup node, but they failed to maintain the QoS parameters and energy consumption. For instance RNF manage to handle failure by moving a small block of neighbor actors toward the failed node in order to recover the communication among them. Even though this manages the recovery of the network but it enlarges the recovery scope and cascade relocation. Such behavior should be eliminated in recovery algorithms. In addition, due to the fact that WSANs are deployed in harsh areas and require long term monitoring/acting process, proposed methods should offer robust self-healing failure detection/ recovery techniques which ensure that the network lifetime is maximized as much as possible while maintaining QoS.</p><p>In WSANs, the nodes track their neighbors by using heart beat messages to avoid any possible interruption. Moreover, algorithms are used to define the critical nodes using 1-hop or 2-hop message exchange information [<xref rid="B8-sensors-17-00858" ref-type="bibr">8</xref>,<xref rid="B36-sensors-17-00858" ref-type="bibr">36</xref>,<xref rid="B40-sensors-17-00858" ref-type="bibr">40</xref>]. In addition, they identify the actor node failure by the interaction of those heartbeat messages with this particular actor node. Thus, there is possibility of interruption due to losing the trail of heart beat messages. Monitoring actor failure detection using 2-hop neighbor list is efficient once it is combined with QoS measurement capabilities, i.e., packet delivery and forwarding techniques should support efficient packet handling and forwarding. Also, we should minimize the through critical actor nodes. Thus, in our proposed model, we assume that each actor node stores the information up to 2-hops to keep the extended trail information. This helps determine the forwarding capability of the actor nodes. The model aims to ensure the contention-free forwarding capability that minimizes the loss of packets in case of node failure. To determine the actor&#x02019;s forwarding capability, each actor conveys the group of beacon messages using different power strengths. Furthermore, the neighbor of each actor listens and returns the value in response. After the neighbor actor receives the message, it starts calculating its RSSI value and sends it back to the sender actor. The RSSI model is used to calculate the distance. It has also been combined with further techniques for better accuracy and to find the relative error. Equations (1)&#x02013;(5) illustrate applying RSSI in actor nodes [<xref rid="B55-sensors-17-00858" ref-type="bibr">55</xref>]. RSSI can also be used to determine the link quality measurement in wireless sensor networks [<xref rid="B56-sensors-17-00858" ref-type="bibr">56</xref>].The RSSI shows the relationship between the received energy of the wireless signals and transmitted energy and the required distance among the actor-sensor nodes. This process helps determine failure node recovery process given in Definition 1. The relationship is given by Equation (1):<disp-formula id="FD1-sensors-17-00858"><label>(1)</label><mml:math id="mm1"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>r</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:msup><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math id="mm2"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Received energy of wireless signals, <inline-formula><mml:math id="mm3"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: transmitted energy of wireless signals, <inline-formula><mml:math id="mm4"><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:math></inline-formula>: Distance between forwarding and receiving node, and <inline-formula><mml:math id="mm5"><mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:math></inline-formula>: Path loss transmission factor whose value depends on the environment.</p><p>Taking the logarithm of Equation (1) provides:<disp-formula id="FD2-sensors-17-00858"><label>(2)</label><mml:math id="mm6"><mml:mrow><mml:mrow><mml:mn>10</mml:mn><mml:mi>log</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mi>log</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>10</mml:mn><mml:mi>&#x003b2;</mml:mi><mml:mi>log</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math id="mm7"><mml:mrow><mml:mrow><mml:mn>10</mml:mn><mml:mi>log</mml:mi><mml:mi>E</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>: Description of energy that could be converted into <inline-formula><mml:math id="mm8"><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>B</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Therefore, Equation (2) can be converted to its <inline-formula><mml:math id="mm9"><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>B</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> form as:<disp-formula id="FD3-sensors-17-00858"><label>(3)</label><mml:math id="mm10"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mi>B</mml:mi><mml:mi>m</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>&#x003b3;</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>10</mml:mn><mml:mi>&#x003b2;</mml:mi><mml:mi>log</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math id="mm11"><mml:mrow><mml:mi mathvariant="sans-serif">&#x003b3;</mml:mi></mml:mrow></mml:math></inline-formula>: transmission parameter.</p><p>Here, <inline-formula><mml:math id="mm12"><mml:mrow><mml:mi>&#x003b3;</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm13"><mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:math></inline-formula> represent the relationship between the strength of the received signals and the distance of the signal transmission among sensor-to-sensor, actor-to-sensor or actor-to-actor.</p><p>RSSI propagation models cover free-space model, log-normal shadow model and ground bidirectional [<xref rid="B20-sensors-17-00858" ref-type="bibr">20</xref>]. In this study free space model is used due to following conditions.</p><list list-type="simple"><list-item><label>&#x025aa;</label><p>The transmission distance is larger than carrier wavelength and antenna size.</p></list-item><list-item><label>&#x025aa;</label><p>There is no obstacle between forwarding actor and either receiving actor or sensor.</p></list-item></list><p>The transmission energy of the wireless signals and the energy of the received signals of sensor nodes located at distance of &#x02018;<italic>r</italic>&#x02019; can be obtained by Equations (4) and (5):<disp-formula id="FD4-sensors-17-00858"><label>(4)</label><mml:math id="mm14"><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mstyle mathvariant="bold-sans-serif"><mml:mi>&#x003bb;</mml:mi></mml:mstyle><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>4</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>&#x003c9;</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math id="mm15"><mml:mrow><mml:mi mathvariant="sans-serif">&#x003bb;</mml:mi></mml:mrow></mml:math></inline-formula>: 1/Frequency of the actor node, <inline-formula><mml:math id="mm16"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x00026;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: An antenna gains, <inline-formula><mml:math id="mm17"><mml:mrow><mml:mi mathvariant="sans-serif">&#x003c9;</mml:mi></mml:mrow></mml:math></inline-formula>: failure factor of the actor and <inline-formula><mml:math id="mm18"><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:math></inline-formula>: distance of the node:<disp-formula id="FD5-sensors-17-00858"><label>(5)</label><mml:math id="mm19"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>&#x003c9;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mi>B</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mi>log</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>gt</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>gr</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>&#x000a0;</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>10</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mi>log</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mstyle mathvariant="bold-sans-serif" mathsize="normal"><mml:mi>&#x003bb;</mml:mi></mml:mstyle><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>4</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Equation (5) represents the signal attenuation using a logarithmic expression. Assume a field with k actor nodes <inline-formula><mml:math id="mm20"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm21"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm22"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,..., <inline-formula><mml:math id="mm23"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. The coordinates of the actor nodes are <inline-formula><mml:math id="mm24"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> for <italic>i</italic> = 1, 2,&#x02026;, <italic>k</italic>. The actor nodes transmit the information regarding their location with their signal strength to the sensor nodes {<inline-formula><mml:math id="mm25"><mml:mrow><mml:mrow><mml:msub><mml:mi mathvariant="normal">s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext>&#x000a0;</mml:mtext><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mo>.</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mo>.</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext>&#x000a0;</mml:mtext><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mi mathvariant="normal">n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>}. The locations of the sensor nodes are unknown. The estimated distances of the actor nodes are calculated from the received signals. In the proposed model, the actor nodes broadcast signals to all sensors. The actor nodes are also responsible for estimating the distances between them and sensor nodes. Let <inline-formula><mml:math id="mm26"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> be an actor node located at <inline-formula><mml:math id="mm27"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> and sensor node is located at <inline-formula><mml:math id="mm28"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="normal">y</mml:mi><mml:mo>,</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mi mathvariant="normal">z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>. Focusing on the relative error <inline-formula><mml:math id="mm29"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> relating to <inline-formula><mml:math id="mm30"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, suppose that the actor node reads a distance <inline-formula><mml:math id="mm31"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, but the correct distance is <inline-formula><mml:math id="mm32"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Therefore, the relative error can be obtained by Equation (6):<disp-formula id="FD6-sensors-17-00858"><label>(6)</label><mml:math id="mm33"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02208;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>+</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The relation between actual distance and the measured distance can be obtained by Equation (7):<disp-formula id="FD7-sensors-17-00858"><label>(7)</label><mml:math id="mm34"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mn>10</mml:mn><mml:mfrac><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> which can be reduced to Equation (8):<disp-formula id="FD8-sensors-17-00858"><label>(8)</label><mml:math id="mm35"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mfrac><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The probability distribution of the location of the actor node based on beacon messages is described in the following definition.</p><statement><label><bold>Definition</bold>&#x000a0;<bold>1.</bold></label><p><italic>Let</italic>
<inline-formula><mml:math id="mm36"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>be an actor node located at</italic>
<inline-formula><mml:math id="mm37"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>that sends information to a sensor using RSSI model with standard deviation</italic>
<inline-formula><mml:math id="mm38"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:mi>&#x003c3;</mml:mi><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>and path loss</italic>
<inline-formula><mml:math id="mm39"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></statement><p><italic>Let</italic>
<inline-formula><mml:math id="mm40"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>be the calculated distance from the actor node</italic>
<inline-formula><mml:math id="mm41"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>at the sensor node. The probability density function for correct location</italic>
<inline-formula><mml:math id="mm42"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>of the sensor node is obtained by Equation (9):</italic>
<disp-formula id="FD9-sensors-17-00858"><label>(9)</label><mml:math id="mm43"><mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msubsup><mml:mi>E</mml:mi><mml:mrow><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mfrac><mml:mrow><mml:mn>10</mml:mn><mml:mi>&#x003b2;</mml:mi><mml:mi>exp</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>log</mml:mi><mml:mi>&#x003b2;</mml:mi><mml:mi>log</mml:mi><mml:mfrac><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>z</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>&#x003c3;</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mi>&#x003c3;</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mi>log</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>z</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
<italic>Probability distribution can be simplified due to an actor</italic>
<inline-formula><mml:math id="mm44"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>with Equation (10):</italic>
<disp-formula id="FD10-sensors-17-00858"><label>(10)</label><mml:math id="mm45"><mml:mrow><mml:mrow><mml:msubsup><mml:mi>E</mml:mi><mml:mrow><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003a8;</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>This can further be extended by using finite set of actors <inline-formula><mml:math id="mm46"><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm47"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm48"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,&#x02026;, <inline-formula><mml:math id="mm49"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>} that produces Definition 2.</p><statement><label><bold>Definition</bold>&#x000a0;<bold>2.</bold></label><p><italic>Let</italic>
<inline-formula><mml:math id="mm50"><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm51"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm52"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,..., <inline-formula><mml:math id="mm53"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>} be the set of the actors sending information to the set of sensor nodes using RSSI model with path loss exponent</italic>
<inline-formula><mml:math id="mm54"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:mi>&#x003b2;</mml:mi><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></statement><p><italic>If the calculated distance from the actor node</italic>
<inline-formula><mml:math id="mm55"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>at the sensor nodes S</italic> = <italic>{</italic><inline-formula><mml:math id="mm56"><mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>}, then the probability density function of correct location</italic>
<inline-formula><mml:math id="mm57"><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>of the sensor nodes can be obtained by:</italic><disp-formula id="FD11-sensors-17-00858"><label>(11)</label><mml:math id="mm58"><mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>&#x003a8;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:msub><mml:mi>&#x003a8;</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>&#x0222b;</mml:mo></mml:mstyle><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>&#x0222b;</mml:mo></mml:mstyle><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mstyle displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:msub><mml:mi>&#x003a8;</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>d</mml:mi><mml:mi>z</mml:mi><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
<italic>where</italic>
<inline-formula><mml:math id="mm59"><mml:mrow><mml:mrow><mml:mi>&#x003a8;</mml:mi><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula><italic>: probability distribution because of an actor</italic>
<inline-formula><mml:math id="mm60"><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>.</italic></p><statement><label><bold>Definition</bold>&#x000a0;<bold>3.</bold></label><p><italic>Assume an actor node <italic>a<sub>i</sub></italic> reads a sample distance</italic>
<inline-formula><mml:math id="mm61"><mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm62"><mml:mrow><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>using beacon messages</italic>
<inline-formula><mml:math id="mm63"><mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula><italic>,</italic>
<inline-formula><mml:math id="mm64"><mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>that is modeled with RSSI with path loss</italic>
<inline-formula><mml:math id="mm65"><mml:mrow><mml:mi>&#x003b2;</mml:mi></mml:mrow></mml:math></inline-formula>
<italic>and standard deviation</italic>
<inline-formula><mml:math id="mm66"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:mi>&#x003c3;</mml:mi><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic>If &#x02018;R&#x02019; provides the mean sample distances and</italic>
<inline-formula><mml:math id="mm67"><mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<italic>is the mean standard deviation, then the square of the actual distance from actor to sensor using beacons can be determined as:</italic>
<disp-formula id="FD12-sensors-17-00858"><label>(12)</label><mml:math id="mm68"><mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>R</mml:mi><mml:mn>4</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>&#x003c3;</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p></statement><p><italic>Furthermore, square standard deviation can be found as:</italic>
<disp-formula id="FD13-sensors-17-00858"><label>(13)</label><mml:math id="mm69"><mml:mrow><mml:mrow><mml:msup><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>100</mml:mn><mml:msup><mml:mi>&#x003b2;</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>log</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>&#x000a0;</mml:mo><mml:mi>log</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mi>&#x003c3;</mml:mi><mml:mi>R</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The definition shows that the actual distance is greatly dependent on the distribution of the measured ranges.</p><p>Hence, our proposed formulas for RSSI-based wireless node location are optimized and modified. They are different from the original RSSI-based formulas. We focused particularly on the energy consumed for transmission and receiving the data including determining the distance between actor-sensor nodes and error rate for finding location of the node that helps identifying the accurate position of the deployed actor nodes for events. Thus, the previous model is used by our proposed algorithm in order to identify the node locations during deployment in addition to during the network lifetime.</p></sec><sec id="sec4dot2-sensors-17-00858"><title>4.2. Optimized Deterministic Actor Recovery System Model</title><p>The network consists of multiple actors and sensor nodes that are structured with the hierarchical structure of the nodes. The hierarchical structure of the nodes provides an efficient, fast and logical packet forwarding patterns. It also determines the features of all nodes connected with WSANs. Another advantage of the hierarchical structure is that it helps to start with little multiplexing process for intra-domain routing. As the packets travel further from the source node the model helps to develop higher degree of multiplexing. The nodes of different categories in WSAN as depicted in <xref ref-type="fig" rid="sensors-17-00858-f003">Figure 3</xref> possess the assorted nodes types. The network aims to use the resources efficiently for each packet forwarded by an actor node. In addition, it reduces the latency while keeping the network more stable.</p><statement><label><bold>Definition</bold>&#x000a0;<bold>4.</bold></label><p><italic>Critical actor node is the actor node which its failure cause network partitioning</italic>.</p></statement><statement><label><bold>Definition</bold>&#x000a0;<bold>5.</bold></label><p><italic>Non-critical nodes (NCNs) are regular actor nodes.</italic>
</p></statement><statement><label><bold>Definition</bold>&#x000a0;<bold>6.</bold></label><p><italic>Cut Vertex Nodes (CVNs) are nodes which have a cut-vertex link with a critical node, i.e., neighbors of critical node</italic>.</p></statement><statement><label><bold>Definition</bold>&#x000a0;<bold>7.</bold></label><p><italic>The Critical Backup Nodes (CBNs) are actor nodes that are assigned to be the backup nodes for a critical node</italic>.</p></statement><p>The EAR consists of actor nodes, sensor nodes, and base station. Actor node can be critical or non-critical. Critical actor node is the actor node which its failure causes network partitioning. Non-critical nodes are regular actor node. Sensors node are used to monitor the network for event detection.</p><p>In this topology, Cut Vertex Nodes (CVNs) are responsible for the removal of the paths that lead to the critical nodes. When the actor node becomes a critical node, then it is necessary to redirect the traffic of the neighbor nodes to the non-critical nodes. Thus, this task is done by removing the vertex (a path leading to critical nodes) and redirecting the traffic, as it further helps improving the throughput performance and reduces the latency. The Critical Backup Nodes (CBNs) replace the actor nodes when the actor nodes become the critical nodes. We assume that the number of critical backup nodes are more than actor nodes in the network. If all the actor nodes become critical nodes, then replacement should be much easier to avoid any kind of interruption or data loss. There could a possibility of disconnecting the direct communication links of the actor nodes towards the backup nodes when the actor nodes start moving. Thus, we also assume that the links of the actor nodes lead to the backup nodes are always stable despite the mobility. Therefore, there is a high possibility to easily replace the critical nodes with CVNs. The actor node has a privilege to collect the data from event-monitoring nodes (sensor nodes), then it forwards the packets to either base station or sensor /actor nodes in the network. On the other hand, the least degree Non Critical Nodes (NCNs) are preferred to be labeled as backup nodes for event-monitoring nodes.</p><p>A neighbor node that is available in Node Distance range (ND) has a similar Cut Vertex Node Distance (CVND). This helps reduce the recovery time and overhead which is important for resource-constrained mission-critical applications.</p><p>In the network, each actor node maintains its 2-hop neighbors&#x02019; information using heartbeat messages. This information helps to maintain the network state, defining critical actor; as well as assigning backup node for the critical actor. Each actor node saves its neighbors information which includes node ID, RSSI value, number of neighbors which is denoted by the degree of node, node criticality (critical actor/non-critical actor), and node distance. Once a critical node is detected, the backup assignment process is executed in-order to assign a backup node for this critical node. The 2-hop node information is used in the process of backup node selection. Depending on RSSI value (extracted from mathematical model), the non-critical node with the least node degree is preferred to be chosen as a backup node. In case there is more than one neighbor with the same node degree, the neighbor with the least distance is preferred. For each critical actor, a pre-assigned backup actor node is selected which is called Critical Backup Nodes CBN. Consequently, CBN monitors its critical node through heartbeats messages and handles the backup process in case the failure of its critical node. Missing a number of successive heartbeats messages at CBN indicates the failure of the primary.</p><p>The topology of the WSAN can be changed during the network lifetime due to the mobility feature of actors, actor node failure, or event handling. Backup nodes are subject to failure as well. Therefore, there are primary backup nodes that select other backup nodes in case of primary backup nodes fail or move beyond the range of ND. To ensure the effectiveness and availability of backup node, we introduce novel backup node selection process in case of primary backup is either failed or in critical condition given in Algorithm 1. Algorithm 1 shows the backup selection process. In this process, the condition of primary backup <inline-formula><mml:math id="mm70"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> node is checked. If a primary backup node is in critical condition or ready to move, then a secondary backup node <inline-formula><mml:math id="mm71"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is chosen. However, if a secondary backup node <inline-formula><mml:math id="mm72"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is in critical condition or ready to move, then tertiary backup node <italic>T<sub>b</sub></italic> is notified to play a role as primary backup node. If the tertiary backup node is in critical condition then the backup assignment algorithm executes and a backup node is assigned.</p><p>Since actor nodes are rich-resource nodes, we further use the least square approximation formulation to identify the power strength. This involves little computational overhead which can be easily attuned in an actor so that we identify the power strength because there is a probability of the node to mislay the power at some particular time.</p><array orientation="portrait"><tbody><tr><td align="left" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><bold>Algorithm 1:</bold> Backup Node Selection Process</td></tr><tr><td align="left" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1"><inline-formula><mml:math id="mm73"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Primary Backup; <inline-formula><mml:math id="mm74"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Critical Primary Backup; <inline-formula><mml:math id="mm75"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Moving Primary Backup; <inline-formula><mml:math id="mm76"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Secondary Backup; <inline-formula><mml:math id="mm77"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Critical Secondary Backup; <inline-formula><mml:math id="mm78"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Moving Secondary Backup; <inline-formula><mml:math id="mm79"><mml:mrow><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Tertiary Backup. <list list-type="order"><list-item><p><bold>Input:</bold> (<inline-formula><mml:math id="mm80"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>)</p></list-item><list-item><p><bold>Output:</bold> (<inline-formula><mml:math id="mm81"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>)</p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm82"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> =<inline-formula><mml:math id="mm83"><mml:mrow><mml:mrow><mml:mtext>&#x000a0;</mml:mtext><mml:mi>P</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> || <inline-formula><mml:math id="mm84"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//The condition of primary backup node is checked.</p></list-item><list-item><p>Notify <inline-formula><mml:math id="mm85"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and Set (<inline-formula><mml:math id="mm86"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,<inline-formula><mml:math id="mm87"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>//Secondary backup node is assigned as primary backup node</p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm88"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> == <inline-formula><mml:math id="mm89"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> || <inline-formula><mml:math id="mm90"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//The condition of Secondary backup node is checked.</p></list-item><list-item><p>Notify <inline-formula><mml:math id="mm91"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and Set (<inline-formula><mml:math id="mm92"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,<inline-formula><mml:math id="mm93"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>//Tertiary backup node is notified to play a role as primary backup node</p></list-item><list-item><p><bold>end if</bold></p></list-item></list></td></tr></tbody></array><p>We use node monitoring process to monitor the node pre-failure causes, the post-failure causes and allocates the recovery options. Once each critical actor node picks a suitable backup, then it is informed through regular heartbeat messages (Special signals are sent to neighbor node to play a role as backup node for critical node). Furthermore, the pre-designated backup initiates monitoring its primary actor node through heartbeats. If a number of consecutive heartbeats are missed from the primary actor, then it notifies that the primary actor failed. Thus, a backup node replacement process is started as given in algorithm 1. Before substantiating the post failure process, we must ensure that connection is not interrupted because of the network. In addition, any redundant action of the network must be controlled to avoid any possible increase of the network overhead. The pre-failure backup node process is given in Algorithm 2.</p><array orientation="portrait"><tbody><tr><td align="left" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><bold>Algorithm 2:</bold> Node Monitoring and Critical Node Detection (NMCND) process</td></tr><tr><td align="left" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">{
<inline-formula><mml:math id="mm94"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Pre-Failure; <inline-formula><mml:math id="mm95"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Post-Failure; <inline-formula><mml:math id="mm96"><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Recovery process; <inline-formula><mml:math id="mm97"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Critical node; <inline-formula><mml:math id="mm98"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Backup node; <inline-formula><mml:math id="mm99"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Primary actor; <inline-formula><mml:math id="mm100"><mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Message heartbeat; <inline-formula><mml:math id="mm101"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Sink node} <list list-type="order"><list-item><p><bold>Input: {</bold><inline-formula><mml:math id="mm102"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>;<inline-formula><mml:math id="mm103"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>;<inline-formula><mml:math id="mm104"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>}</p></list-item><list-item><p><bold>Output</bold>: {<inline-formula><mml:math id="mm105"><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="mm106"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>;<inline-formula><mml:math id="mm107"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>}</p></list-item><list-item><p><bold>Set</bold>
<inline-formula><mml:math id="mm108"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Number of actor nodes are set as primary actors in the network</p></list-item><list-item><p><inline-formula><mml:math id="mm109"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> broadcasts <inline-formula><mml:math id="mm110"><mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Sink node broadcasts the message to all primary actor nodes</p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm111"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm112"><mml:mrow><mml:mo>&#x02260;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm113"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//</p></list-item><list-item><p>Determine <inline-formula><mml:math id="mm114"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Initiate critical node discovery process</p></list-item><list-item><p><bold>If</bold> &#x02200; <inline-formula><mml:math id="mm115"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: <inline-formula><mml:math id="mm116"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> &#x02208; <inline-formula><mml:math id="mm117"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then</p></list-item><list-item><p><inline-formula><mml:math id="mm118"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> assigns <inline-formula><mml:math id="mm119"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>Set</bold>
<inline-formula><mml:math id="mm120"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> = <inline-formula><mml:math id="mm121"><mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm122"><mml:mrow><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> NotDelivered <inline-formula><mml:math id="mm123"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then</p></list-item><list-item><p><bold>Set</bold>
<inline-formula><mml:math id="mm124"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for data delivery</p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>Process</bold>
<inline-formula><mml:math id="mm125"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm126"><mml:mrow><mml:mo>&#x02203;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm127"><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Primary actor node recovery process is conducted</p></list-item><list-item><p><bold>end if</bold></p></list-item></list></td></tr></tbody></array><p>As shown in Algorithm 2, <inline-formula><mml:math id="mm128"><mml:mrow><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> represents the number of actor nodes in the network. Then, the sink node <inline-formula><mml:math id="mm129"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> broadcasts the message to all primary actor nodes to determine pre-failure actor nodes. If primary actor is not identified as pre-failure, then the process of determining the critical actor node will be started in order to choose the backup node. Next, the critical node discovery process is initiated. For each primary node, if the primary node is found as critical node then this node will be defined as critical node <inline-formula><mml:math id="mm130"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and a backup node <inline-formula><mml:math id="mm131"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> selection is assigned. The critical node will broadcast a message to its neighbors which includes the information of its backup node. This information is stored by the neighbors and it is used when starting the network recovery process in case the neighbors detect the failure of their critical actor neighbor. If consecutive heartbeat messages are not received from the critical node, then back node starts replacing the critical node to avoid any kind of packet-forwarding delay. In addition, neighbors of the critical node will use stored information to communicate with the backup node in order to restore connectivity. In conclusion, the recovery process is conducted.</p><p>After the node monitoring process is executed, we proceed further with checking the backup assignment and the critical back up assignment of the nodes. This allows to maintain the network connectivity without generating any disjoint procedure of the network. The possibility of the recovery depends on the cut vertex node. If the backup is a non-critical node, then it simply substitutes the primary actor node, and the recovery process is initiated to confirm the backup actor node. If the backup is also a critical node, then a cut vertex node replacement is completed. The pre-assigned backup actor node instantly activates a recovery process once it senses the failure of its primary actor node. The complete node monitoring including failure, recovery and replacement processes are depicted in <xref ref-type="fig" rid="sensors-17-00858-f004">Figure 4</xref>. In complete node monitoring process, first, the node identification process is initiated. The node is identified based on local neighbor information (LNI) that involves global data position, node property and node degree. The critical node selection process is decided using Algorithms 1 and 2. Once a critical node is identified, it will be assigned a backup node; second, the backup node selection process is started if an actor node fails. The selection process is decided based on monitoring the algorithms explained earlier. Once the backup node selection process is complete, then the backup process starts working in case of node failure. If an actor node does not fail, then the node connectivity monitoring process is started and routing connectivity metrics are checked to ensure whether there is no problem of the router.</p><p>After completion of the actor node failure and node assignment processes, the actor nodes should be linked to forward the collected data to the base station. In response, the base station sends its identity (ID) using network integration message (NIM). When an actor node receives NIM from the base station, it saves the destination address of the base station for packet forwarding (PF). Subsequently, NIM is broadcasted in the network among all the actors. At least one actor node is within the range of the base station to avoid any bottlenecks. Otherwise, the base station receives the data through sensor nodes that could be the cause of packet delay and loss. The actor node saves the information of the first actor node from which it receives NIM to use PF process and further forwards NIM with its ID. If an actor gets NIM from multiple actors, then it stores the identity of additional actors in the buffer list. Identity of the saved actors is used in case of topology changes due to mobility or node failure. The detailed process of an actor node that receives NIM is presented in Algorithm 3.</p><array orientation="portrait"><tbody><tr><td align="left" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><bold>Algorithm 3:</bold> Network Integration and Message Forwarding Process </td></tr><tr><td align="left" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1"><list list-type="order"><list-item><p>{
<inline-formula><mml:math id="mm132"><mml:mrow><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Base Station; NIM: Network integration message; PF: packet forwarding; <inline-formula><mml:math id="mm133"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Node identity; <inline-formula><mml:math id="mm134"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Actor node; <inline-formula><mml:math id="mm135"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Node buffer}</p></list-item><list-item><p><bold>Input: {</bold><inline-formula><mml:math id="mm136"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>,<inline-formula><mml:math id="mm137"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<bold>}</bold></p></list-item><list-item><p><bold>Output</bold>: {NIM, PF}</p></list-item><list-item><p><bold>Set</bold> NIM//Network integration message is set to interconnect the entire network</p></list-item><list-item><p><bold>Set</bold> PF//it saves the destination address of the Base station for packet forwarding</p></list-item><list-item><p><bold>If</bold> PF = <inline-formula><mml:math id="mm138"><mml:mrow><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//If a base station is saved as the destination address</p></list-item><list-item><p>Decline NIM//If base station is found, then NIM is declined </p></list-item><list-item><p><bold>else if</bold> NIM <inline-formula><mml:math id="mm139"><mml:mrow><mml:mrow><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//</p></list-item><list-item><p><bold>Set</bold> PF= <inline-formula><mml:math id="mm140"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>// Data forwarding packet is given ID transmitted to Base station</p></list-item><list-item><p>Transmit NIM </p></list-item><list-item><p><bold>else if</bold> NIM <inline-formula><mml:math id="mm141"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm142"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//It will be considered that NIM is forwarded by an actor node</p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>end else</bold></p></list-item><list-item><p><bold>If</bold> PF <inline-formula><mml:math id="mm143"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm144"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> //If it is validated that data packet is forwarded by an actor node, t</p></list-item><list-item><p><inline-formula><mml:math id="mm145"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> stores <inline-formula><mml:math id="mm146"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> into <inline-formula><mml:math id="mm147"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//When actor node receives NIM from multiple actors</p></list-item><list-item><p><inline-formula><mml:math id="mm148"><mml:mrow><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:mstyle><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><bold>Set</bold> PF = <inline-formula><mml:math id="mm149"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Data forwarding packet is given ID </p></list-item><list-item><p>Transmit NIM//NIM is transmitted by an actor node</p></list-item><list-item><p><bold>End if</bold></p></list-item><list-item><p><bold>end else</bold></p></list-item><list-item><p><bold>else if</bold> NIM <inline-formula><mml:math id="mm150"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm151"><mml:mrow><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//NIM message is broadcasted by the Base station.</p></list-item><list-item><p><bold>If</bold> PF <inline-formula><mml:math id="mm152"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm153"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//If data forwarding packets is from an actor</p></list-item><list-item><p>Decline NIM//If actor node is found, then NIM is declined</p></list-item><list-item><p><bold>else</bold> PF = <inline-formula><mml:math id="mm154"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm155"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm156"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Each forwarded data packet is given identify from an actor</p></list-item><list-item><p>Transmit NIM//network integration message is transmitted by an actor node</p></list-item><list-item><p><bold>end else</bold></p></list-item><list-item><p><bold>end else</bold></p></list-item><list-item><p><bold>end if</bold></p></list-item></list></td></tr></tbody></array><p>Our protocol applies a simple algorithm to process the NIM. The actor node first transmits NIM to its higher hop neighbor actors/sensors. When it gets the first NIM from the higher hop actor/sensor, then it forwards to its lower-hop neighbor actors/sensors to ensure the transmission of NIMs in the entire network. All other NIMs are then dropped by the actor nodes. Therefore, if each actor is ensured to be in the communication range of at least one actor, then the NIMs should not require to be managed at sensor nodes.</p><p>Let us assume that an actor node transmits the number of bits in each packet <inline-formula><mml:math id="mm157"><mml:mrow><mml:mrow><mml:mo>&#x02018;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>&#x02019;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> that uses encoding mechanism to reduce the complexity of each packet. The sensor nodes monitor the events which check its contribution table that specify the important events. If events are of the significant interest, then the sensor nodes generate the packets and forward to the actor node. The complete process of monitoring the events and forwarding the routing of the data packets is given in Algorithm 4.</p><array orientation="portrait"><tbody><tr><td align="left" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><bold>Algorithm 4:</bold> Priority-Based Routing for Node Failure Avoidance Process </td></tr><tr><td align="left" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>{</bold><inline-formula><mml:math id="mm158"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Packet rate; <inline-formula><mml:math id="mm159"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Actor node; <inline-formula><mml:math id="mm160"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Significant; <inline-formula><mml:math id="mm161"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: First interest, <inline-formula><mml:math id="mm162"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Sharing capacity of node; P: Packet; <inline-formula><mml:math id="mm163"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> : remaining output capacity of the node; <inline-formula><mml:math id="mm164"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Efficient packet rate; <inline-formula><mml:math id="mm165"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Flag of interest; <inline-formula><mml:math id="mm166"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Flag of uninterested;<inline-formula><mml:math id="mm167"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>: Node failure}<list list-type="order"><list-item><p><bold>Input:</bold> {<inline-formula><mml:math id="mm168"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, P }</p></list-item><list-item><p><bold>Output:</bold> {<inline-formula><mml:math id="mm169"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm170"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> }</p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm171"><mml:mrow><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> received by <inline-formula><mml:math id="mm172"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//If actor node receives the packet</p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm173"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm174"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> then//If the received packet is of significant interest</p></list-item><list-item><p>Set <inline-formula><mml:math id="mm175"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//If condition in step-4 is satisfied, received first packet is considered as significant of interest.</p></list-item><list-item><p>Set <inline-formula><mml:math id="mm176"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> +1 &#x00026; decrease <inline-formula><mml:math id="mm177"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm178"><mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>y</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> //Sharing capacity of the node is increased</p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>end if</bold></p></list-item><list-item><p><bold>If</bold>
<inline-formula><mml:math id="mm179"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> &#x0003e; 0 then//Determine the power of node Forw<inline-formula><mml:math id="mm180"><mml:mrow><mml:mrow><mml:mi>ard</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mi>P</mml:mi><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>//Received packet is forwarded</p></list-item><list-item><p>Set <inline-formula><mml:math id="mm181"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Flag of interest is set in the buffer</p></list-item><list-item><p><bold>Else if</bold>
<inline-formula><mml:math id="mm182"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> &#x0003c; 0 then</p></list-item><list-item><p>Process <inline-formula><mml:math id="mm183"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> &#x0003e; <inline-formula><mml:math id="mm184"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> &#x00026; P <inline-formula><mml:math id="mm185"><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm186"><mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//Showing that packet rate is higher than efficient packet rate</p></list-item><list-item><p>Increase <inline-formula><mml:math id="mm187"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="mm188"><mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>y</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>/ remaining capacity of the actor node is increased</p></list-item><list-item><p>Reduce <inline-formula><mml:math id="mm189"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>//When capacity of the node is increased, less possibility of node failure</p></list-item><list-item><p><bold>end else</bold></p></list-item><list-item><p><bold>end if</bold></p></list-item></list></td></tr></tbody></array></sec></sec><sec id="sec5-sensors-17-00858"><title>5. Simulation Setup and Experimental Results</title><p>There are two processes running throughout the network&#x02019;s deployment and monitoring, the underlying process obtains individual node properties while the second monitors the network consistency. Our goal is to prolong the network lifetime while maintaining the minimum overhead and determining the nodes&#x02019; failure causes. We have implemented and simulated efficient actor recovery protocol over wireless sensors and actor networks. The simulation is conducted on OMNET++ simulator. The size of the network is 1400 &#x000d7; 1400 square meters. Nodes are deployed randomly in the network. The main objective of simulation is to determine the performance of the proposed EAR algorithm in order to ensure the effectiveness of the protocol in presence of QoS parameters, energy efficiency when incident of node failure occurs. In addition, the performance of proposed EAR algorithm is compared with known similar type of schemes such as RNF, DPCRA, ACR, and ACRA.</p><p>RNF, DPCRA, ACR, and ACRA are state-of-the-art actor failure recovery algorithms. Detailed description was provided in <xref ref-type="sec" rid="sec3-sensors-17-00858">Section 3</xref>. The proposed algorithms manages cut-vertex actor failure and recovery while they differ in their selection and objective obtained while recovery as given in <xref ref-type="table" rid="sensors-17-00858-t001">Table 1</xref>. The similar parameters including properties have been used for testing purposes.</p><p>The simulation scenario consists of 400 nodes including 27&#x02013;54 actor nodes and 173&#x02013;356 sensor nodes with a transmission range of 70 m. The sensor/actor nodes are arbitrarily deployed in a mesh fashion. The initial energy of the actor nodes is set 20 J and sensor nodes have 4 J. The bandwidth of the actor node is 4 Mbps, and maximum power consumption of the sensor/actor node for receiving and transmitting the data is set to 13.5 Mw and 15.0 Mw respectively. Sensing and idle modes have 12.4 mW and 0.60 mW, respectively. The total simulation time is 36 min that is enough to determine the effectiveness of the proposed versus stat-of-the-art schemes. However, the simulation time could also be minimized or maximized, and the pause time is 20 s set to warm up the nodes before beginning of the simulation. The results demonstrate presented here are the average of 10 simulation runs. The simulation parameters are summed up in <xref ref-type="table" rid="sensors-17-00858-t002">Table 2</xref>.</p><p>The simulation consists of three simulation scenarios that replicate the real wireless sensors and actor wireless sensor network environment. The obtained simulation results are equitably significant and indistinguishable to realistic tentative results.</p><list list-type="bullet"><list-item><p>Scenario-I: Sensors-to-actor communications. In this scenario, the source nodes are set as the sensors, while the destination nodes are set as actors. The multiple connections are setup with one actor. Thus, the actor node acts as the sink of the communication. There is 86.5%:13.5% ration of sensor-to-actor, and 20% mobile sensor nodes are set. In this scenario, we used different sizes of the network; 1000 &#x000d7; 1000 m<sup>2</sup>, 1200 &#x000d7; 1200 m<sup>2</sup> and 1400 &#x000d7; 1400 m<sup>2</sup>.</p></list-item><list-item><p>Scenario-II: Actor-to-actor communications. In this scenario, the distance between the two actors is 300 m. The distance is covered by less than 4 hops. This scenario involves multi-hop communication among the actors. In this scenario, a maximum 54 actors are used.</p></list-item><list-item><p>Scenario-III: Actor-to-sensor communications. In this scenario, communication is done between actors and sensor. The distance between actor and sensor is set to 250 m. The number of hops are 5 and mobility of the nodes is 20% in this communication. There is 13.5%:86.5% ration of sensor-to-actor, and 20% mobile sensor nodes are set. In this scenario, we used different sizes of the network; 1000 &#x000d7; 1000 m<sup>2</sup>, 1200 &#x000d7; 1200 m<sup>2</sup> and 1400 &#x000d7; 1400 m<sup>2</sup>.</p></list-item></list><p>15&#x02013;70 connections are set up among the nodes. The connections start working randomly during the warm up time. The source and destination nodes are randomly chosen in each scenario. Based on the simulation, we obtained interesting results including the following parameters:<list list-type="bullet"><list-item><p>Number of alive Days.</p></list-item><list-item><p>Residual Energy.</p></list-item><list-item><p>Actor/Sensor Recovery time.</p></list-item><list-item><p>Data Recovery.</p></list-item><list-item><p>Time Complexity.</p></list-item></list></p><sec id="sec5dot1-sensors-17-00858"><title>5.1. Number of Alive Days</title><p>Extended network lifetime has a significant role in improving the performance of the applications. In <xref ref-type="fig" rid="sensors-17-00858-f005">Figure 5</xref>, <xref ref-type="fig" rid="sensors-17-00858-f006">Figure 6</xref> and <xref ref-type="fig" rid="sensors-17-00858-f007">Figure 7</xref>, the performance of EAR is shown and compared with RNF, DPCRA, ACR, and ACRA in form of number of alive nodes. In these experiments, we used the results of three scenarios with different network topologies. In scenario-1, we used 1200 &#x000d7; 1200 m<sup>2</sup> network size with number of maximum 200 nodes that include 27 actor and 173 sensor nodes. Sixty five connections are established to cover the entire scenario. Based on the results, we observed that 24 nodes have 78 alive days in our approach and same days with compared approaches, but when the number of nodes increase up to maximum 200 nodes, then the number of alive days are different. Our approach has slight edge over other competing approaches. In our approach, the nodes are alive up to 367 days as compared with other approaches that have less alive days. RNF approach has 323 alive days, and ACRA has 362 alive days. In scenario-1, our proposed EAR has improvement over other competing approaches of 1.36&#x02013;11.98%. In scenario-2, we used 1000 &#x000d7; 1000 m<sup>2</sup> network size with number of maximum 54 actor nodes with 15 connections. Based on the results, we observed that actors are alive for 643 days in our approach, while other approaches have actor life of 512&#x02013;592 days. ACR approach has less 512 alive days, and RNF has 588 alive days. In scenario-2, our proposed EAR has improvement over other competing approaches of 7.93&#x02013;20.37%.</p><p>In scenario-3, we used 1400 &#x000d7; 1400 m<sup>2</sup> network size with number of maximum 400 nodes that include 54 actor and 346 sensor nodes. Seventy five connections are established to cover the entire network scenario. Based on the results, we observed that nodes have lifetime 671 days in our proposed EAR approach, whereas other approaches have alive nodes 485&#x02013;571 days. The performance of the network in ACRA is greatly affected which has minimum of 485 alive days. Therefore, our proposed EAR has improvement over other competing approaches of 14.9&#x02013;27.71% in scenaroio-3.</p><p>The reason of the better stability of our approach is the usage of the RSSI model that helps to determine the proper distance between sensor-to-sensor, sensor-to-actor and actor-to-actor nodes. Furthermore, the network integration message process connects the entire network. As a result, bottlenecks are avoided. In case of the node failure, the backup node discovery process is initiated, that does not only improve the throughput, but also extends the nodes&#x02019; lifetime.</p></sec><sec id="sec5dot2-sensors-17-00858"><title>5.2. Residual Energy</title><p>The residual energy is the remaining energy level of the actor/sensor nodes when concluding the event(s). Here, we discuss an average residual energy level of the actor/sensor nodes after monitoring of different number of events. <xref ref-type="fig" rid="sensors-17-00858-f008">Figure 8</xref>, <xref ref-type="fig" rid="sensors-17-00858-f009">Figure 9</xref> and <xref ref-type="fig" rid="sensors-17-00858-f010">Figure 10</xref> compare the residual energy of EAR with those of the RNF, DPCRA, ACR, and ACRA at nine, 18 and 27 events respectively. The sensor/actor nodes have a higher residual energy with the EAR after completion of the events. In this experiment, the results are obtained based on three scenarios: <disp-formula id="FD14-sensors-17-00858"><label>(14)</label><mml:math id="mm190"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>*</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>*</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:msup><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mtext>&#x000a0;</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="sans-serif">&#x00394;</mml:mi><mml:msub><mml:mi>C</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>*</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>*</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>*</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mtext>&#x000a0;</mml:mtext><mml:msup><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mtext>&#x000a0;</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mtext>&#x000a0;</mml:mtext></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>In <xref ref-type="fig" rid="sensors-17-00858-f008">Figure 8</xref>, 70 connections are established for nine events. The actor-to-actor are 12 connections, actor-to-sensor are 32 connections and sensor-to-sensor are 26 connections. Each connection consumes different energy. However, we obtained an average of overall residual energy for the entire network based on the number of connections. We observed in <xref ref-type="fig" rid="sensors-17-00858-f008">Figure 8</xref> that the residual energy of our proposed approach has 8.4 J with nine events as compared with other approaches have residual energy ranging from 6.9&#x02013;8.2 J. When we increased the events up to 18 in the <xref ref-type="fig" rid="sensors-17-00858-f009">Figure 9</xref>, the residual energy of our approach marginally dropped and became 7.4 J and competing approaches have residual energy from 4.2&#x02013;5.9 J. In <xref ref-type="fig" rid="sensors-17-00858-f008">Figure 8</xref> and <xref ref-type="fig" rid="sensors-17-00858-f009">Figure 9</xref>, RNF has less residual energy due to sending additional control message during the actor node failure process. In <xref ref-type="fig" rid="sensors-17-00858-f010">Figure 10</xref>, EAR has 6.7 J of residual energy whereas other competing approaches have 3.4&#x02013;5.2 J residual energy. ACR has minimum residual energy when the number of events increase in <xref ref-type="fig" rid="sensors-17-00858-f010">Figure 10</xref>. The reason of the minimum residual energy is due to the decision tree that is incorporated in the reactive routing protocol. Our approach has higher residual energy for all events because our proposed model determines the forwarding capacity of each sensor/actor node prior to transmission which helps to avoid the node failure. The residual energy of sensor/actor is calculated using Equation (14) and the description of the used notations is given in <xref ref-type="table" rid="sensors-17-00858-t003">Table 3</xref>.</p></sec><sec id="sec5dot3-sensors-17-00858"><title>5.3. Actor/Sensor Recovery Time</title><p>The actor recovery time is of high significance for network improvement and running applications on it. When the actor fails, then it is important to initiate the prompt recovery process to avoid the reduction in the network performance. <xref ref-type="fig" rid="sensors-17-00858-f011">Figure 11</xref> and <xref ref-type="fig" rid="sensors-17-00858-f012">Figure 12</xref> show the actor recovery time of the proposed EAR algorithm and other competing approaches: RNF, DPCRA, ACR, and ACRA. In these experiments, we used two different network topologies: 1200 &#x000d7; 1200 m<sup>2</sup> and 1400 &#x000d7; 1400 m<sup>2</sup>. In <xref ref-type="fig" rid="sensors-17-00858-f011">Figure 11</xref>, we used 1200 &#x000d7; 1200 m<sup>2</sup> network topology with 48 connections.</p><p>Based on the results, we observed that EAR has overall minimum actor/sensor recovery time. We determined an actor recovery time for maximum 27 failure nodes including 11 actors and 16 sensors nodes. At the maximum of 27 failure nodes, EAR has 3.25 s actor/sensor recovery time while other approaches have 3.6&#x02013;4.7 s. The results show that EAR has 3.19&#x02013;20% improvement over other competing approaches.</p><p>In <xref ref-type="fig" rid="sensors-17-00858-f012">Figure 12</xref>, we used 1400 &#x000d7; 1400 m<sup>2</sup> network topology with 60 connections. Based on the results, we observed that EAR has overall minimum actor recovery time. We determined an actor/sensor recovery time for maximum 27 failure nodes including 11 actors and 16 sensors nodes. At the maximum 27 failure nodes, EAR has the same time of 3.25 s as obtained with 1200 &#x000d7; 1200 m<sup>2</sup> network topology with 60 connections. It is confirmed that the increase in the network topology does not affect the actor/sensor recovery time while other approaches have 3.62&#x02013;4.75 s. The result show that EAR has 3.21&#x02013;20.8% improvement over other competing approaches.</p><p>The results confirm the soundness EAR in terms of an actor recovery time due to contention-free forwarding capacity of the nodes. In addition, particular RSSI value is selected for traffic forwarding process that makes the process of actor recovery much easier. As, all of the existing approaches either attempt to recover the failure actor or try to reduce the overhead, but our proposed approach reduces the power consumption and delivers the data without contention. Furthermore, it improves the backup node selection process in case of node failure or being disjoint. These characteristics of EAR help reduce the actor recovery time as compared with other approaches.</p></sec><sec id="sec5dot4-sensors-17-00858"><title>5.4. Data Recovery</title><p>Although data loss is very critical issue, very little information is publically released even when substantial data is lost. A wide variety of failures can cause physical mutilation to the quality of service of the applications. To retain the lost data, the backup recovery approaches perform vital role. However, data recovery methods are not capable enough particularly in wireless sensor and actor networks. In our proposed approach, we have a node monitoring algorithm that monitor the status of the node prior to failure as well as post-failure.</p><p>As a result, backup nodes take the responsibility of storing the data. <xref ref-type="fig" rid="sensors-17-00858-f013">Figure 13</xref> and <xref ref-type="fig" rid="sensors-17-00858-f014">Figure 14</xref> show data loss and recovered data with 1400 &#x000d7; 1400 m<sup>2</sup> network topology using 72 connections. In <xref ref-type="fig" rid="sensors-17-00858-f013">Figure 13</xref>, the total data loss is 15 KB when monitoring 10 events. Based on the results, we observed that EAR lost 15 KB data and recovered 15 KB that shows our scheme of data recovery is fault-tolerant, whereas other approaches also lost the same amount of data, but recovered 11.1&#x02013;13.5 KB data. It is confirmed that EAR has 10%&#x02013;26% improvement over other competing approaches.</p><p>In <xref ref-type="fig" rid="sensors-17-00858-f014">Figure 14</xref>, data loss is 30 KB with 20 events. As some of the events are not highly critical so that less amount of data is lost with 20 events. As EAR recovers 29.82 KB out of 30 KB that is quite better recovery as compared with other competing approaches. The other competing approaches are greatly affected due to the increase in events so that other approaches have recovery data from 23.8 to 29.1 KB. The least adaptable data recovery algorithm is DPCRA with 20 events. The results also validates that EAR has 2.41%&#x02013;20.66% improvement over other competing approaches.</p></sec><sec id="sec5dot5-sensors-17-00858"><title>5.5. Time Complexity</title><p>The quality of the running applications depends on the time complexity of algorithm. The time complexity is normally measured by calculating the number of basic operations and time consumed for those operations performed by the algorithm. The algorithm that takes less time improves the performance of the running applications. In <xref ref-type="fig" rid="sensors-17-00858-f015">Figure 15</xref>, we show the average time consumed for input data processing by EAR algorithm in comparison with RNF, ACRA, ACR and DPCRA. Based on the experimental results, we observed that EAR sent more input data in minimum time as compared with other competing algorithms. EAR sent maximum 54 KB input data within 0.065 s, whereas other protocols took 0.067&#x02013;0.094 s in sending the same amount of data. EAR achieves minimum time because using the single operation for either pre-failure or post-failure recovery processes help reducing the time complexity.</p><p>To analyze the time complexity of EAR, lets determine the processes involved in the pre-failure and post failure process. In EAR, each critical actor node has a pre-assigned backup actor node which monitors its critical node. If consecutive heartbeat messages are not received from the critical node, backup actor node handles the recovery process. Let&#x02019;s assume the critical actor is designated as (AC) and its backup node is designated (AB), the following instructions illustrate the pre-failure process: </p><preformat>        {If (AB.HeartbeatMonitor(AC) == false);
        Ab.Recover(AC);
        }</preformat><p>While post failure process is handled by the backup node (AB). Thus, AB moves towards the failed actor (AC) location in order to recover the network partition. Also, the neighbors of the critical node will use the stored information to communicate with the backup node (AB) in order to restore connectivity.</p><preformat>        PostFailure(AC, AB) 
        { 
        Move(AB, c); 
        Connect(AB, Neighbors(AC)) 
        }</preformat><p>To calculate the time complexity for the previous operation, we assume that each process takes a time <italic>T</italic>(<italic>n</italic>) which is illustrated in <xref ref-type="table" rid="sensors-17-00858-t004">Table 4</xref>. As shown in <xref ref-type="table" rid="sensors-17-00858-t004">Table 4</xref>, each statement takes O(1).</p><p><xref ref-type="fig" rid="sensors-17-00858-f016">Figure 16</xref> is used to represent the time complexity analysis of different algorithms. It is used to illustrate the complexity description of the algorithms. The time complexity of EAR and other competing algorithms is obtained using Big O notation is given in <xref ref-type="table" rid="sensors-17-00858-t005">Table 5</xref>.</p></sec><sec id="sec5dot6-sensors-17-00858"><title>5.6. Overall Performance of EAR</title><p>Based on the experimental results, we show the significance and improvement of EAR approach and comparison of other approaches in <xref ref-type="table" rid="sensors-17-00858-t006">Table 6</xref>.</p></sec></sec><sec id="sec6-sensors-17-00858"><title>6. Conclusions</title><p>An Efficient Actor Recovery (EAR) algorithm is introduced in this paper. The approach is based on the Received Signal Strength (RSSI). Unlike most published approaches, EAR differentiates between critical and non-critical nodes and allocates a suitable backup node from its neighboring nodes, which is also chosen based on the signal strength and regulates the nodes in its surrounding locality. EAR consists of novel RSSI model that helps applying probability density function for finding the correct location of the sensor node. In addition, it shows the relationship between the received energy of the wireless signals and transmitted energy including the required distance among the actor-sensor nodes. Furthermore, EAR is supported by three algorithms for performing the network monitoring process, network integration and message forwarding process, and routing process for actor node to avoid the failure node. EAR approach has been validated using simulation of OMNET++ and compared with other known approaches; RNF, DPCRA, ACR, and ACRA. The experimental results demonstrate that EAR outperforms other competing approaches in terms of data recovery, number of alive days of the nodes, residual energy and data loss.</p></sec></body><back><notes><title>Author Contributions</title><p>This research paper is part of Reem Mahjoub&#x02019;s dissertation, and it has been conducted under the supervision of Khaled Elleithy. Extensive discussions of the proposed scheme were carried between the authors over the past year.</p></notes><notes notes-type="COI-statement"><title>Conflicts of Interest</title><p>The authors declare no conflict of interest.</p></notes><ref-list><title>References</title><ref id="B1-sensors-17-00858"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akyildiz</surname><given-names>I.F.</given-names></name><name><surname>Kasimoglu</surname><given-names>I.H.</given-names></name></person-group><article-title>Wireless sensor and actorq networks: Research challenges</article-title><source>Ad Hoc Netw.</source><year>2004</year><volume>2</volume><fpage>351</fpage><lpage>367</lpage><pub-id pub-id-type="doi">10.1016/j.adhoc.2004.04.003</pub-id></element-citation></ref><ref id="B2-sensors-17-00858"><label>2.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Melodia</surname><given-names>T.</given-names></name><name><surname>Pompili</surname><given-names>D.</given-names></name><name><surname>Akyildiz</surname><given-names>I.F.</given-names></name></person-group><article-title>A communication architecture for mobile wireless sensor and actor networks</article-title><source>Proceedings of the 2006 3rd Annual IEEE Communications Society on Sensor and Ad Hoc Communications and Networks</source><conf-loc>Reston, VA, USA</conf-loc><conf-date>25&#x02013;28 September 2006</conf-date><fpage>109</fpage><lpage>118</lpage></element-citation></ref><ref id="B3-sensors-17-00858"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>A.</given-names></name><name><surname>Ren</surname><given-names>J.</given-names></name><name><surname>Li</surname><given-names>X.</given-names></name><name><surname>Chen</surname><given-names>Z.</given-names></name><name><surname>Shen</surname><given-names>X.</given-names></name></person-group><article-title>Design principles and improvement of cost function based energy aware routing algorithms for wireless sensor networks</article-title><source>Comput. Netw.</source><year>2012</year><volume>56</volume><fpage>1951</fpage><lpage>1967</lpage><pub-id pub-id-type="doi">10.1016/j.comnet.2012.01.023</pub-id></element-citation></ref><ref id="B4-sensors-17-00858"><label>4.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Youssef</surname><given-names>A.M.</given-names></name><name><surname>Youssef</surname><given-names>M.</given-names></name></person-group><article-title>A taxonomy of localization schemes for wireless sensor networks</article-title><source>Proceedings of the 2007 International Conference on Wireless Networks (ICWN)</source><conf-loc>Las Vegas, NV, USA</conf-loc><conf-date>25&#x02013;28 June 2007</conf-date><fpage>444</fpage><lpage>450</lpage></element-citation></ref><ref id="B5-sensors-17-00858"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name></person-group><article-title>Strategies and techniques for node placement in wireless sensor networks: A survey</article-title><source>Ad Hoc Netw.</source><year>2008</year><volume>6</volume><fpage>621</fpage><lpage>655</lpage><pub-id pub-id-type="doi">10.1016/j.adhoc.2007.05.003</pub-id></element-citation></ref><ref id="B6-sensors-17-00858"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>Y.</given-names></name><name><surname>Jeon</surname><given-names>C.</given-names></name></person-group><article-title>Actor positioning with minimal movement in wireless sensor and actor networks</article-title><source>Int. J. Distrib. Sens. Netw.</source><year>2015</year><volume>2015</volume><fpage>9</fpage><pub-id pub-id-type="doi">10.1155/2015/135831</pub-id></element-citation></ref><ref id="B7-sensors-17-00858"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akkaya</surname><given-names>K.</given-names></name><name><surname>Senel</surname><given-names>F.</given-names></name><name><surname>Thimmapuram</surname><given-names>A.</given-names></name><name><surname>Uludag</surname><given-names>S.</given-names></name></person-group><article-title>Distributed recovery from network partitioning in movable sensor/actor networks via controlled mobility</article-title><source>IEEE Trans. Comput.</source><year>2010</year><volume>59</volume><fpage>258</fpage><lpage>271</lpage><pub-id pub-id-type="doi">10.1109/TC.2009.120</pub-id></element-citation></ref><ref id="B8-sensors-17-00858"><label>8.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Alfadhly</surname><given-names>A.</given-names></name><name><surname>Baroudi</surname><given-names>U.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>Least distance movement recovery approach for large scale wireless sensor and actor networks</article-title><source>Proceedings of the 2011 7th International Wireless Communications and Mobile Computing Conference</source><conf-loc>Istanbul, Turkey</conf-loc><conf-date>4&#x02013;8 July 2011</conf-date><fpage>2058</fpage><lpage>2063</lpage></element-citation></ref><ref id="B9-sensors-17-00858"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Du</surname><given-names>J.</given-names></name><name><surname>Xie</surname><given-names>L.</given-names></name><name><surname>Sun</surname><given-names>X.</given-names></name><name><surname>Zheng</surname><given-names>R.</given-names></name></person-group><article-title>Application-oriented fault detection and recovery algorithm for wireless sensor and actor networks</article-title><source>Int. J. Distrib. Sens. Netw.</source><year>2012</year><volume>8</volume><pub-id pub-id-type="doi">10.1155/2012/273792</pub-id></element-citation></ref><ref id="B10-sensors-17-00858"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.A.</given-names></name><name><surname>Younis</surname><given-names>M.F.</given-names></name><name><surname>Baroudi</surname><given-names>U.A.</given-names></name></person-group><article-title>Recovering from a node failure in wireless sensor-actor networks with minimal topology changes</article-title><source>IEEE Trans. Veh. Technol.</source><year>2013</year><volume>62</volume><fpage>256</fpage><lpage>271</lpage><pub-id pub-id-type="doi">10.1109/TVT.2012.2212734</pub-id></element-citation></ref><ref id="B11-sensors-17-00858"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ranga</surname><given-names>V.</given-names></name><name><surname>Dave</surname><given-names>M.</given-names></name><name><surname>Verma</surname><given-names>A.K.</given-names></name></person-group><article-title>A hybrid timer based single node failure recovery approach for wsans</article-title><source>Wirel. Pers. Commun.</source><year>2014</year><volume>77</volume><fpage>2155</fpage><lpage>2182</lpage><pub-id pub-id-type="doi">10.1007/s11277-014-1631-4</pub-id></element-citation></ref><ref id="B12-sensors-17-00858"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Lee</surname><given-names>M.</given-names></name></person-group><article-title>Connectivity restoration in a partitioned wireless sensor network with assured fault tolerance</article-title><source>Ad Hoc Netw.</source><year>2015</year><volume>24</volume><fpage>1</fpage><lpage>19</lpage><pub-id pub-id-type="doi">10.1016/j.adhoc.2014.07.012</pub-id></element-citation></ref><ref id="B13-sensors-17-00858"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ranga</surname><given-names>V.</given-names></name><name><surname>Dave</surname><given-names>M.</given-names></name><name><surname>Verma</surname><given-names>A.K.</given-names></name></person-group><article-title>Recovery of lost connectivity in wireless sensor and actor networks using static sensors as bridge routers</article-title><source>Procedia Comput. Sci.</source><year>2015</year><volume>70</volume><fpage>491</fpage><lpage>498</lpage><pub-id pub-id-type="doi">10.1016/j.procs.2015.10.089</pub-id></element-citation></ref><ref id="B14-sensors-17-00858"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>S.</given-names></name><name><surname>Wu</surname><given-names>X.</given-names></name><name><surname>Huang</surname><given-names>C.</given-names></name></person-group><article-title>Adaptive topology reconfiguration from an actor failure in wireless sensor-actor networks</article-title><source>Int. J. Distrib. Sens. Netw.</source><year>2015</year><volume>11</volume><fpage>602471</fpage><pub-id pub-id-type="doi">10.1155/2015/602471</pub-id></element-citation></ref><ref id="B15-sensors-17-00858"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>H.</given-names></name><name><surname>Ding</surname><given-names>X.</given-names></name><name><surname>Huang</surname><given-names>C.</given-names></name><name><surname>Wu</surname><given-names>X.</given-names></name></person-group><article-title>Adaptive connectivity restoration from node failure(s) in wireless sensor networks</article-title><source>Sensors</source><year>2016</year><volume>16</volume><elocation-id>1487</elocation-id><pub-id pub-id-type="doi">10.3390/s16101487</pub-id><pub-id pub-id-type="pmid">27690030</pub-id></element-citation></ref><ref id="B16-sensors-17-00858"><label>16.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Krishnakumar</surname><given-names>S.S.</given-names></name><name><surname>Abler</surname><given-names>R.T.</given-names></name></person-group><article-title>Intelligent actor mobility in wireless sensor and actor networks</article-title><source>Proceedings of the Wireless Sensor and Actor Networks: IFIP WG 6.8 FIRST international Conference on Wireless Sensor and Actor Networks (WSAN&#x02019;07)</source><conf-loc>Albacete, Spain</conf-loc><conf-date>24&#x02013;26 September 2007</conf-date><person-group person-group-type="editor"><name><surname>Orozco-Barbosa</surname><given-names>L.</given-names></name><name><surname>Olivares</surname><given-names>T.</given-names></name><name><surname>Casado</surname><given-names>R.</given-names></name><name><surname>Berm&#x000fa;dez</surname><given-names>A.</given-names></name></person-group><publisher-name>Springer</publisher-name><publisher-loc>Boston, MA, USA</publisher-loc><year>2007</year><fpage>13</fpage><lpage>22</lpage></element-citation></ref><ref id="B17-sensors-17-00858"><label>17.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Caruso</surname><given-names>A.</given-names></name><name><surname>Paparella</surname><given-names>F.</given-names></name><name><surname>Vieira</surname><given-names>L.F.M.</given-names></name><name><surname>Erol</surname><given-names>M.</given-names></name><name><surname>Gerla</surname><given-names>M.</given-names></name></person-group><article-title>The meandering current mobility model and its impact on underwater mobile sensor networks</article-title><source>Proceedings of the IEEE27th Conference on Computer Communications (INFOCOM)</source><conf-loc>Phoenix, AZ, USA</conf-loc><conf-date>13&#x02013;18 April 2008</conf-date></element-citation></ref><ref id="B18-sensors-17-00858"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>X.</given-names></name><name><surname>Santoro</surname><given-names>N.</given-names></name><name><surname>Stojmenovic</surname><given-names>I.</given-names></name></person-group><article-title>Localized distance-sensitive service discovery in wireless sensor and actor networks</article-title><source>IEEE Trans. Comput.</source><year>2009</year><volume>58</volume><fpage>1275</fpage><lpage>1288</lpage></element-citation></ref><ref id="B19-sensors-17-00858"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Melodia</surname><given-names>T.</given-names></name><name><surname>Pompili</surname><given-names>D.</given-names></name><name><surname>Akyldiz</surname><given-names>I.F.</given-names></name></person-group><article-title>Handling mobility in wireless sensor and actor networks</article-title><source>IEEE Trans. Mob. Comput.</source><year>2010</year><volume>9</volume><fpage>160</fpage><lpage>173</lpage><pub-id pub-id-type="doi">10.1109/TMC.2009.102</pub-id></element-citation></ref><ref id="B20-sensors-17-00858"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zeng</surname><given-names>Y.</given-names></name><name><surname>Li</surname><given-names>D.</given-names></name><name><surname>Vasilakos</surname><given-names>A.V.</given-names></name></person-group><article-title>Real-time data report and task execution in wireless sensor and actuator networks using self-aware mobile actuators</article-title><source>Comput. Commun.</source><year>2013</year><volume>36</volume><fpage>988</fpage><lpage>997</lpage><pub-id pub-id-type="doi">10.1016/j.comcom.2012.07.016</pub-id></element-citation></ref><ref id="B21-sensors-17-00858"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akbas</surname><given-names>M.</given-names></name><name><surname>Erol-Kantarci</surname><given-names>M.</given-names></name><name><surname>Turgut</surname><given-names>D.</given-names></name></person-group><article-title>Localization for wireless sensor and actor networks with meandering mobility</article-title><source>IEEE Trans. Comput.</source><year>2014</year><volume>64</volume><fpage>1015</fpage><lpage>1028</lpage><pub-id pub-id-type="doi">10.1109/TC.2014.2315647</pub-id></element-citation></ref><ref id="B22-sensors-17-00858"><label>22.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Elmazi</surname><given-names>D.</given-names></name><name><surname>Kulla</surname><given-names>E.</given-names></name><name><surname>Oda</surname><given-names>T.</given-names></name><name><surname>Spaho</surname><given-names>E.</given-names></name><name><surname>Barolli</surname><given-names>L.</given-names></name><name><surname>Uchida</surname><given-names>K.</given-names></name></person-group><article-title>Selection of actor nodes in wireless sensor and actor networks: A fuzzy based method considering actor mobility</article-title><source>Proceedings of the IEEE 29th International Conference on Advanced Information Networking and Applications Workshops (WAINA 2015)</source><conf-loc>Guwangiu, Korea</conf-loc><conf-date>24&#x02013;27 March 2015</conf-date><fpage>304</fpage><lpage>310</lpage></element-citation></ref><ref id="B23-sensors-17-00858"><label>23.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>P&#x00142;aczek</surname><given-names>B.</given-names></name><name><surname>Bernas</surname><given-names>M.</given-names></name></person-group><article-title>Self-organizing mobility control in wireless sensor and actor networks based on virtual electrostatic interactions</article-title><source>Wirel. Pers. Commun.</source><year>2016</year><fpage>1</fpage><lpage>21</lpage><pub-id pub-id-type="doi">10.1007/s11277-016-3730-x</pub-id></element-citation></ref><ref id="B24-sensors-17-00858"><label>24.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Morita</surname><given-names>K.</given-names></name><name><surname>Ozaki</surname><given-names>K.</given-names></name><name><surname>Watanabe</surname><given-names>K.</given-names></name><name><surname>Hayashibara</surname><given-names>N.</given-names></name><name><surname>Enokido</surname><given-names>T.</given-names></name><name><surname>Takizawa</surname><given-names>M.</given-names></name></person-group><article-title>Sensor-actuator communication protocols in wireless networks</article-title><source>Proceedings of the Network-Based Information Systems: First International Conference (NBIS 2007)</source><conf-loc>Regensburg, Germany</conf-loc><conf-date>3&#x02013;7 September 2007</conf-date><person-group person-group-type="editor"><name><surname>Enokido</surname><given-names>T.</given-names></name><name><surname>Barolli</surname><given-names>L.</given-names></name><name><surname>Takizawa</surname><given-names>M.</given-names></name></person-group><publisher-name>Springer</publisher-name><publisher-loc>Berlin/Heidelberg, Germany</publisher-loc><year>2007</year><fpage>11</fpage><lpage>19</lpage></element-citation></ref><ref id="B25-sensors-17-00858"><label>25.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Almasaeid</surname><given-names>H.M.</given-names></name><name><surname>Kamal</surname><given-names>A.E.</given-names></name></person-group><article-title>Data delivery in fragmented wireless sensor networks using mobile agents</article-title><source>Proceedings of the 10th ACM Symposium on Modeling, Analysis, and Simulation of Wireless And Mobile Systems (ACM 2007)</source><conf-loc>Chania, Greece</conf-loc><conf-date>22&#x02013;26 October 2007</conf-date><fpage>86</fpage><lpage>94</lpage></element-citation></ref><ref id="B26-sensors-17-00858"><label>26.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Senel</surname><given-names>F.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>An efficient mechanism for establishing connectivity in wireless sensor and actor networks</article-title><source>Proceedings of the IEEE GLOBECOM 2007&#x02014;IEEE Global Telecommunications Conference</source><conf-loc>Washington, DC, USA</conf-loc><conf-date>26&#x02013;30 November 2007</conf-date><fpage>1129</fpage><lpage>1133</lpage></element-citation></ref><ref id="B27-sensors-17-00858"><label>27.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Curiac</surname><given-names>D.-I.</given-names></name></person-group><article-title>Towards wireless sensor, actuator and robot networks</article-title><source>J. Netw. Comput. Appl.</source><year>2016</year><volume>63</volume><fpage>14</fpage><lpage>23</lpage><pub-id pub-id-type="doi">10.1016/j.jnca.2016.01.013</pub-id></element-citation></ref><ref id="B28-sensors-17-00858"><label>28.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.</given-names></name><name><surname>Baroudi</surname><given-names>U.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name></person-group><article-title>C2am: An algorithm for application-aware movement-assisted recovery in wireless sensor and actor networks</article-title><source>Proceedings of the 2009 International Conference on Wireless Communications and Mobile Computing: Connecting the World Wirelessly (ACM 2009)</source><conf-loc>Leipzig, Germany</conf-loc><conf-date>21&#x02013;24 June 2009</conf-date><fpage>655</fpage><lpage>659</lpage></element-citation></ref><ref id="B29-sensors-17-00858"><label>29.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Senturk</surname><given-names>I.F.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name><name><surname>Le</surname><given-names>S.</given-names></name><name><surname>Senel</surname><given-names>F.</given-names></name></person-group><article-title>Topology management techniques for tolerating node failures in wireless sensor networks: A survey</article-title><source>Comput. Netw.</source><year>2014</year><volume>58</volume><fpage>254</fpage><lpage>283</lpage><pub-id pub-id-type="doi">10.1016/j.comnet.2013.08.021</pub-id></element-citation></ref><ref id="B30-sensors-17-00858"><label>30.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.A.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name></person-group><article-title>Movement-assisted connectivity restoration in wireless sensor and actor networks</article-title><source>IEEE Trans. Parallel Distrib. Syst.</source><year>2009</year><volume>20</volume><fpage>1366</fpage><lpage>1379</lpage><pub-id pub-id-type="doi">10.1109/TPDS.2008.246</pub-id></element-citation></ref><ref id="B31-sensors-17-00858"><label>31.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Li</surname><given-names>W.</given-names></name><name><surname>Liu</surname><given-names>D.</given-names></name><name><surname>Zhu</surname><given-names>B.</given-names></name><name><surname>Wei</surname><given-names>X.</given-names></name><name><surname>Xiao</surname><given-names>W.</given-names></name><name><surname>Yang</surname><given-names>L.</given-names></name></person-group><article-title>Sdn control model for intelligent task execution in wireless sensor and actor networks</article-title><source>Proceedings of the 2016 IEEE 83rd Vehicular Technology Conference (VTC Spring)</source><conf-loc>Nanjing, China</conf-loc><conf-date>15&#x02013;18 May 2016</conf-date><fpage>1</fpage><lpage>5</lpage></element-citation></ref><ref id="B32-sensors-17-00858"><label>32.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.A.</given-names></name><name><surname>Younis</surname><given-names>M.F.</given-names></name><name><surname>Baroudi</surname><given-names>U.A.</given-names></name></person-group><article-title>A least-movement topology repair algorithm for partitioned wireless sensor-actor networks</article-title><source>Int. J. Sens. Netw.</source><year>2012</year><volume>11</volume><fpage>250</fpage><lpage>262</lpage><pub-id pub-id-type="doi">10.1504/IJSNET.2012.047152</pub-id></element-citation></ref><ref id="B33-sensors-17-00858"><label>33.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Imran</surname><given-names>M.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Said</surname><given-names>A.M.</given-names></name><name><surname>Hasbullah</surname><given-names>H.</given-names></name></person-group><article-title>Volunteer-instigated connectivity restoration algorithm for wireless sensor and actor networks</article-title><source>Proceedings of the IEEE International Conference on Wireless Communications, Networking and Information Security (WCNIS)</source><conf-loc>Beijing, China</conf-loc><conf-date>25&#x02013;27 June 2010</conf-date><fpage>679</fpage><lpage>683</lpage></element-citation></ref><ref id="B34-sensors-17-00858"><label>34.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>alfadhly</surname><given-names>A.</given-names></name><name><surname>Baroudi</surname><given-names>U.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>Optimal node repositioning for tolerating node failure in wireless sensor actor network</article-title><source>Proceedings of the 2010 25th Biennial Symposium on Communications (QBSC)</source><conf-loc>Kingston, ON, Canada</conf-loc><conf-date>12&#x02013;14 May 2010</conf-date><fpage>67</fpage><lpage>71</lpage></element-citation></ref><ref id="B35-sensors-17-00858"><label>35.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.A.</given-names></name><name><surname>Akkaya</surname><given-names>K.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>A distributed connectivity restoration algorithm in wireless sensor and actor networks</article-title><source>Proceedings of the 32nd IEEE Conference on Local Computer Networks</source><conf-loc>Dublin</conf-loc><conf-date>15&#x02013;18 October 2007</conf-date><fpage>496</fpage><lpage>503</lpage></element-citation></ref><ref id="B36-sensors-17-00858"><label>36.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Haider</surname><given-names>N.</given-names></name><name><surname>Imran</surname><given-names>M.</given-names></name><name><surname>Saad</surname><given-names>N.M.</given-names></name><name><surname>Zakariya</surname><given-names>M.A.</given-names></name></person-group><article-title>Performance analysis of reactive connectivity restoration algorithms for wireless sensor and actor networks</article-title><source>Proceedings of the 2013 IEEE Malaysia International Conference on Communications (MICC)</source><conf-loc>Kuala Lumpur, Malaysia</conf-loc><conf-date>26&#x02013;28 November 2013</conf-date><fpage>490</fpage><lpage>495</lpage></element-citation></ref><ref id="B37-sensors-17-00858"><label>37.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Baroudi</surname><given-names>U.</given-names></name></person-group><article-title>Restoring connectivity in wireless sensor-actor networks with minimal topology changes</article-title><source>Proceedings of the IEEE International Conference on Communications (ICC 2010)</source><conf-loc>Cape Town, South Africa</conf-loc><conf-date>23&#x02013;27 May 2010</conf-date><fpage>1</fpage><lpage>5</lpage></element-citation></ref><ref id="B38-sensors-17-00858"><label>38.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Imran</surname><given-names>M.</given-names></name><name><surname>Said</surname><given-names>A.M.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Hasbullah</surname><given-names>H.</given-names></name></person-group><article-title>Application-centric connectivity restoration algorithm for wireless sensor and actor networks</article-title><source>Proceedings of the 6th international Conference on Advances in Grid and Pervasive Computing, 2011</source><conf-loc>Oulu, Finland</conf-loc><conf-date>11&#x02013;13 May 2011</conf-date><fpage>243</fpage><lpage>253</lpage></element-citation></ref><ref id="B39-sensors-17-00858"><label>39.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Abbasi</surname><given-names>A.A.</given-names></name></person-group><article-title>A localized algorithm for restoring internode connectivity in networks of moveable sensors</article-title><source>IEEE Trans. Comput.</source><year>2010</year><volume>59</volume><fpage>1669</fpage><lpage>1682</lpage><pub-id pub-id-type="doi">10.1109/TC.2010.174</pub-id></element-citation></ref><ref id="B40-sensors-17-00858"><label>40.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Imran</surname><given-names>M.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Said</surname><given-names>A.M.</given-names></name><name><surname>Hasbullah</surname><given-names>H.</given-names></name></person-group><article-title>Localized motion-based connectivity restoration algorithms for wireless sensor and actor networks</article-title><source>J. Netw. Appl.</source><year>2012</year><volume>35</volume><fpage>844</fpage><lpage>856</lpage><pub-id pub-id-type="doi">10.1016/j.jnca.2011.12.002</pub-id></element-citation></ref><ref id="B41-sensors-17-00858"><label>41.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Alfadhly</surname><given-names>A.</given-names></name><name><surname>Baroudi</surname><given-names>U.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>An effective approach for tolerating simultaneous failures in wireless sensor and actor networks</article-title><source>Proceedings of the first ACM international workshop on Mission-oriented wireless sensor networking</source><conf-loc>Istanbul, Turkey</conf-loc><conf-date>26 August 2012</conf-date><publisher-name>ACM</publisher-name><publisher-loc>Istanbul, Turkey</publisher-loc><year>2012</year><fpage>21</fpage><lpage>26</lpage></element-citation></ref><ref id="B42-sensors-17-00858"><label>42.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Younis</surname><given-names>M.</given-names></name><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Gupta</surname><given-names>S.</given-names></name><name><surname>Fisher</surname><given-names>K.</given-names></name></person-group><article-title>A localized self-healing algorithm for networks of moveable sensor nodes</article-title><source>Proceedings of the 2008 IEEE Global Telecommunications Conference (GLOBECOM 2008)</source><conf-loc>New Orleans, LA, USA</conf-loc><conf-date>30 November&#x02013;4 December 2008</conf-date><fpage>1</fpage><lpage>5</lpage></element-citation></ref><ref id="B43-sensors-17-00858"><label>43.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sumalatha</surname><given-names>G.</given-names></name><name><surname>Zareena</surname><given-names>N.</given-names></name><name><surname>Gopi Raju</surname><given-names>C.</given-names></name></person-group><article-title>A review on failure node recovery algorithms in wireless sensor actor networks</article-title><source>Int. J. Comput. Trends Technol.</source><year>2014</year><volume>12</volume><fpage>94</fpage><lpage>98</lpage><pub-id pub-id-type="doi">10.14445/22312803/IJCTT-V12P118</pub-id></element-citation></ref><ref id="B44-sensors-17-00858"><label>44.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Erol-Kantarci</surname><given-names>M.</given-names></name><name><surname>Mouftah</surname><given-names>H.T.</given-names></name></person-group><article-title>Wireless multimedia sensor and actor networks for the next generation power grid</article-title><source>Ad Hoc Netw.</source><year>2011</year><volume>9</volume><fpage>542</fpage><lpage>551</lpage><pub-id pub-id-type="doi">10.1016/j.adhoc.2010.08.005</pub-id></element-citation></ref><ref id="B45-sensors-17-00858"><label>45.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Reina</surname><given-names>D.G.</given-names></name><name><surname>Toral</surname><given-names>S.L.</given-names></name><name><surname>Johnson</surname><given-names>P.</given-names></name><name><surname>Barrero</surname><given-names>F.J.</given-names></name></person-group><article-title>Route duration improvement in wireless sensor and actuator networks based on mobility parameters and flooding control</article-title><source>EURASIP J. Wirel. Commun. Netw.</source><year>2012</year><volume>2012</volume><fpage>147</fpage><pub-id pub-id-type="doi">10.1186/1687-1499-2012-147</pub-id></element-citation></ref><ref id="B46-sensors-17-00858"><label>46.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Adewumi</surname><given-names>O.G.</given-names></name><name><surname>Djouani</surname><given-names>K.</given-names></name><name><surname>Kurien</surname><given-names>A.M.</given-names></name></person-group><article-title>Rssi based indoor and outdoor distance estimation for localization in wsn</article-title><source>Proceedings of the 2013 IEEE International Conference on Industrial Technology (ICIT)</source><conf-loc>Cape Town, South Africa</conf-loc><conf-date>25&#x02013;28 February 2013</conf-date><fpage>1534</fpage><lpage>1539</lpage></element-citation></ref><ref id="B47-sensors-17-00858"><label>47.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ahir</surname><given-names>A.</given-names></name><name><surname>Rakhunde</surname><given-names>H.</given-names></name></person-group><article-title>An efficient approach towards recovery from node failure in wireless sensor network</article-title><source>Int. J. Innov. Res. Sci. Technol.</source><year>2015</year><volume>2</volume><fpage>3</fpage><lpage>5</lpage></element-citation></ref><ref id="B48-sensors-17-00858"><label>48.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akkaya</surname><given-names>K.</given-names></name><name><surname>Senel</surname><given-names>F.</given-names></name><name><surname>McLaughlan</surname><given-names>B.</given-names></name></person-group><article-title>Clustering of wireless sensor and actor networks based on sensor distribution and connectivity</article-title><source>J. Parallel Distrib. Comput.</source><year>2009</year><volume>69</volume><fpage>573</fpage><lpage>587</lpage><pub-id pub-id-type="doi">10.1016/j.jpdc.2009.02.004</pub-id></element-citation></ref><ref id="B49-sensors-17-00858"><label>49.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Khan</surname><given-names>S.</given-names></name><name><surname>Khan</surname><given-names>F.</given-names></name><name><surname>Khan</surname><given-names>S.A.</given-names></name></person-group><article-title>Delay and throughput performance improvement in wireless sensor and actor networks</article-title><source>Proceedings of the 2015 5th National Symposium on Information Technology: Towards New Smart World (NSITNSW)</source><conf-loc>Riyadh, Saudi Arabia</conf-loc><conf-date>17&#x02013;19 February 2015</conf-date><fpage>1</fpage><lpage>5</lpage></element-citation></ref><ref id="B50-sensors-17-00858"><label>50.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Imran</surname><given-names>M.</given-names></name><name><surname>Zafar</surname><given-names>N.A.</given-names></name></person-group><article-title>Formal specification and validation of a hybrid connectivity restoration algorithm for wireless sensor and actor networks</article-title><source>Sensors</source><year>2012</year><volume>12</volume><fpage>11754</fpage><lpage>11781</lpage><pub-id pub-id-type="doi">10.3390/s120911754</pub-id></element-citation></ref><ref id="B51-sensors-17-00858"><label>51.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>S.</given-names></name><name><surname>Peng</surname><given-names>J.</given-names></name><name><surname>Liu</surname><given-names>W.</given-names></name><name><surname>Zhu</surname><given-names>Z.</given-names></name><name><surname>Lin</surname><given-names>K.-C.</given-names></name></person-group><article-title>A uniform energy consumption algorithm for wireless sensor and actuator networks based on dynamic polling point selection</article-title><source>Sensors</source><year>2014</year><volume>14</volume><fpage>95</fpage><lpage>116</lpage><pub-id pub-id-type="doi">10.3390/s140100095</pub-id><pub-id pub-id-type="pmid">24451455</pub-id></element-citation></ref><ref id="B52-sensors-17-00858"><label>52.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>J.</given-names></name><name><surname>D&#x000ed;az</surname><given-names>M.</given-names></name><name><surname>Llopis</surname><given-names>L.</given-names></name><name><surname>Rubio</surname><given-names>B.</given-names></name><name><surname>Troya</surname><given-names>J.M.</given-names></name></person-group><article-title>A survey on quality of service support in wireless sensor and actor networks: Requirements and challenges in the context of critical infrastructure protection</article-title><source>J. Netw. Comput. Appl.</source><year>2011</year><volume>34</volume><fpage>1225</fpage><lpage>1239</lpage><pub-id pub-id-type="doi">10.1016/j.jnca.2011.01.008</pub-id></element-citation></ref><ref id="B53-sensors-17-00858"><label>53.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Joshi</surname><given-names>Y.K.</given-names></name><name><surname>Younis</surname><given-names>M.</given-names></name></person-group><article-title>Autonomous recovery from multi-node failure in wireless sensor network</article-title><source>Proceedings of the 2012 IEEE Global Communications Conference (GLOBECOM)</source><conf-loc>Anaheim, CA, USA</conf-loc><conf-date>3&#x02013;7 December 2012</conf-date><fpage>652</fpage><lpage>657</lpage></element-citation></ref><ref id="B54-sensors-17-00858"><label>54.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mart&#x000ed;nez</surname><given-names>D.</given-names></name><name><surname>Gonz&#x000e1;lez</surname><given-names>A.</given-names></name><name><surname>Blanes</surname><given-names>F.</given-names></name><name><surname>Aquino</surname><given-names>R.</given-names></name><name><surname>Simo</surname><given-names>J.</given-names></name><name><surname>Crespo</surname><given-names>A.</given-names></name></person-group><article-title>Formal specification and design techniques for wireless sensor and actuator networks</article-title><source>Sensors</source><year>2011</year><volume>11</volume><fpage>1059</fpage><lpage>1077</lpage><pub-id pub-id-type="doi">10.3390/s110101059</pub-id><pub-id pub-id-type="pmid">22344203</pub-id></element-citation></ref><ref id="B55-sensors-17-00858"><label>55.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>J.</given-names></name><name><surname>Liu</surname><given-names>W.</given-names></name><name><surname>Lang</surname><given-names>F.</given-names></name><name><surname>Zhang</surname><given-names>Y.</given-names></name><name><surname>Wang</surname><given-names>C.</given-names></name></person-group><article-title>Distance measurement model based on rssi in wsn</article-title><source>Wirel. Sens. Netw.</source><year>2010</year><volume>2</volume><fpage>606</fpage><lpage>611</lpage><pub-id pub-id-type="doi">10.4236/wsn.2010.28072</pub-id></element-citation></ref><ref id="B56-sensors-17-00858"><label>56.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Razaque</surname><given-names>A.</given-names></name><name><surname>Khaled</surname><given-names>M.E.</given-names></name></person-group><article-title>Energy-efficient boarder node medium access control protocol for wireless sensor networks</article-title><source>Sensors</source><year>2014</year><volume>14</volume><fpage>5074</fpage><lpage>5117</lpage><pub-id pub-id-type="doi">10.3390/s140305074</pub-id><pub-id pub-id-type="pmid">24625737</pub-id></element-citation></ref></ref-list></back><floats-group><fig id="sensors-17-00858-f001" orientation="portrait" position="float"><label>Figure 1</label><caption><p>WSAN Architecture.</p></caption><graphic xlink:href="sensors-17-00858-g001"/></fig><fig id="sensors-17-00858-f002" orientation="portrait" position="float"><label>Figure 2</label><caption><p>Critical actor node in WSAN.</p></caption><graphic xlink:href="sensors-17-00858-g002"/></fig><fig id="sensors-17-00858-f003" orientation="portrait" position="float"><label>Figure 3</label><caption><p>Nodes Types in EAR.</p></caption><graphic xlink:href="sensors-17-00858-g003"/></fig><fig id="sensors-17-00858-f004" orientation="portrait" position="float"><label>Figure 4</label><caption><p>Efficient Actor Recovery system model implementation.</p></caption><graphic xlink:href="sensors-17-00858-g004"/></fig><fig id="sensors-17-00858-f005" orientation="portrait" position="float"><label>Figure 5</label><caption><p>Number of alive nodes after completion of 12 events with 1200 &#x000d7; 1200 m<sup>2</sup> network topology (Results obtained from Scenario-1).</p></caption><graphic xlink:href="sensors-17-00858-g005"/></fig><fig id="sensors-17-00858-f006" orientation="portrait" position="float"><label>Figure 6</label><caption><p>Number of alive nodes after completion of 12 events with 1000 &#x000d7; 1000 m<sup>2</sup> network topology (Results obtained from Scenario-2).</p></caption><graphic xlink:href="sensors-17-00858-g006"/></fig><fig id="sensors-17-00858-f007" orientation="portrait" position="float"><label>Figure 7</label><caption><p>Number of alive nodes after completion of 12 events with 1400 &#x000d7; 1400 m<sup>2</sup> network topology (Results obtained from Scenario-3).</p></caption><graphic xlink:href="sensors-17-00858-g007"/></fig><fig id="sensors-17-00858-f008" orientation="portrait" position="float"><label>Figure 8</label><caption><p>The residual energy of EAR and other competing approaches based on 9 event-monitoring.</p></caption><graphic xlink:href="sensors-17-00858-g008"/></fig><fig id="sensors-17-00858-f009" orientation="portrait" position="float"><label>Figure 9</label><caption><p>The residual energy of EAR and other competing approaches: RNF, DPCRA, ACR, and ACRA based on 18 event-monitoring.</p></caption><graphic xlink:href="sensors-17-00858-g009"/></fig><fig id="sensors-17-00858-f010" orientation="portrait" position="float"><label>Figure 10</label><caption><p>The residual energy of EAR and other competing approaches: RNF, DPCRA, ACR, and ACRA based on 27 event-monitoring.</p></caption><graphic xlink:href="sensors-17-00858-g010"/></fig><fig id="sensors-17-00858-f011" orientation="portrait" position="float"><label>Figure 11</label><caption><p>Number of failure actors/Sensors and required actor recovery time for EAR, RNF, DPCRA, ACR, and ACRA approaches with 1200 &#x000d7; 1200.</p></caption><graphic xlink:href="sensors-17-00858-g011"/></fig><fig id="sensors-17-00858-f012" orientation="portrait" position="float"><label>Figure 12</label><caption><p>Number of failure actors/Sensors and required actor recovery time for EAR, RNF, DPCRA, ACR, and ACRA approaches with 1400 &#x000d7; 1400.</p></caption><graphic xlink:href="sensors-17-00858-g012"/></fig><fig id="sensors-17-00858-f013" orientation="portrait" position="float"><label>Figure 13</label><caption><p>Data loss vs. Data recovery during 10 events.</p></caption><graphic xlink:href="sensors-17-00858-g013"/></fig><fig id="sensors-17-00858-f014" orientation="portrait" position="float"><label>Figure 14</label><caption><p>Data loss vs. Data recovery during 20 events.</p></caption><graphic xlink:href="sensors-17-00858-g014"/></fig><fig id="sensors-17-00858-f015" orientation="portrait" position="float"><label>Figure 15</label><caption><p>Execution Time of EAR, RNF, DPCRA, ACR, and SCRA in terms of seconds.</p></caption><graphic xlink:href="sensors-17-00858-g015"/></fig><fig id="sensors-17-00858-f016" orientation="portrait" position="float"><label>Figure 16</label><caption><p>Big-O Complexity Chart.</p></caption><graphic xlink:href="sensors-17-00858-g016"/></fig><table-wrap id="sensors-17-00858-t001" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t001_Table 1</object-id><label>Table 1</label><caption><p>Compared Algorithms</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Actor Deployment</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Actor Recovery Selection</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Aim</th></tr></thead><tbody><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">ACR</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Random</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">FH selection based on node distance to failed actor</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Actor recovery while Reduce total travel distance</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">RNF</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Random</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Neighbors containing smallest block</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Limit path extend between nodes. </td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">DPCRA</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Random</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">FH handles the recovery based on smallest block of nodes</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Minimum number of recovery nodes having their minimum travel distance</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">ACRA</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Randomly</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Actor node with high transmission power and higher coverage area is selected, and connectivity is recovered</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Recover network from cut-vertex actor failure by limiting actor movement and using sensors as connecting bridges</td></tr></tbody></table></table-wrap><table-wrap id="sensors-17-00858-t002" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t002_Table 2</object-id><label>Table 2</label><caption><p>Summarized simulation parameters for the proposed EAR.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Used Parameters</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Parameters&#x02019; Description</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Transmission Range</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">70 m</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Sensing Range of sensor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">35 m</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Initial energy of a sensor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">4&#x02013;10 J</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Initial energy of an actor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">20&#x02013;40 J</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Sensing Range of an actor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">65 m</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Bandwidth of sensor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">50 Kb/S</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Bandwidth of an actor node</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">4 Mb/s</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Simulation time</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">36 min</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Maximum nodes</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">400</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Number of sensors</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">173&#x02013;346</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Static Sensor</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">80%</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Mobile Sensor</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">20%</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Number of actors</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">27&#x02013;54</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Actor-Sensor Ratio</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">13.5:86.5</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Network Size</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">1000 &#x000d7; 1000 m<sup>2</sup>, 200 &#x000d7; 1200 m<sup>2</sup>, 1400 &#x000d7; 1400 m<sup>2</sup></td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Number of hops in network</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">18 Maximum</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Models</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">EAR, RNF, DPCRA, ACR, and ACRA</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Buffering capacity at sensor and actor</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">50 &#x00026; 300 Packets buffering capacity at each sensor and actor respectively</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Mobility (Speed of the nodes)</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">0 m/s to 12 m/s</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Data Packet size</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">512 bytes</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Initial pause time</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">20 s</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Rx energy</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">12.4 mW</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Tx energy</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">0.60 mW</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>Power Intensity</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;14 dBm to 13 dBm.</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Total simulation time</bold></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">36 min</td></tr></tbody></table></table-wrap><table-wrap id="sensors-17-00858-t003" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t003_Table 3</object-id><label>Table 3</label><caption><p>Notations and descriptions.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Notations</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Descriptions</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm191"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Number of the packets</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm192"><mml:mrow><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Control packets</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm193"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Initial energy</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm194"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Residual energy</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm195"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Energy consumed for the radio signal</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm196"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Energy consumed for amplifying the signal</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><inline-formula><mml:math id="mm197"><mml:mrow><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" rowspan="1" colspan="1">Mean Energy consumed for amplifying the signal and radio</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">h</td><td align="left" valign="middle" rowspan="1" colspan="1">Number of hops</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><inline-formula><mml:math id="mm198"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Number of sensor/actor nodes</td></tr></tbody></table></table-wrap><table-wrap id="sensors-17-00858-t004" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t004_Table 4</object-id><label>Table 4</label><caption><p>Pre-failure and post-failure time analysis of EAR using O Big operation.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Process</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">No. of Statements</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Statement</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Running Time</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Time Complexity</th></tr></thead><tbody><tr><td rowspan="2" align="center" valign="middle" style="border-bottom:solid thin" colspan="1"><bold>Pre-failure process</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">If (AB.HeartbeatMonitor(AC) = false);</td><td align="center" valign="middle" rowspan="1" colspan="1"><italic>T</italic>(<italic>n</italic>) = 1</td><td align="center" valign="middle" rowspan="1" colspan="1">O(1)</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Ab.Recover(AC)</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><italic>T</italic>(<italic>n</italic>) = 1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">O(1)</td></tr><tr><td rowspan="2" align="center" valign="middle" style="border-bottom:solid thin" colspan="1"><bold>Post-Failure</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">move(ab, ac)</td><td align="center" valign="middle" rowspan="1" colspan="1"><italic>T</italic>(<italic>n</italic>) = 1</td><td align="center" valign="middle" rowspan="1" colspan="1">O(1)</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Connect(AB, Neighbors(AC))</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><italic>T</italic>(<italic>n</italic>) = 1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">O(1)</td></tr></tbody></table></table-wrap><table-wrap id="sensors-17-00858-t005" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t005_Table 5</object-id><label>Table 5</label><caption><p>Time Complexity of EAR, RNF, DPCRA, ACR, and ACRA using O Big operation.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Name of Approaches</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Excellent ()</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Description </th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>EAR</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">O(1)</td><td align="center" valign="middle" rowspan="1" colspan="1">Excellent</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>RNF [<xref rid="B10-sensors-17-00858" ref-type="bibr">10</xref>]</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">O(log <italic>n</italic>)</td><td align="center" valign="middle" rowspan="1" colspan="1">Good</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>ACRA [<xref rid="B13-sensors-17-00858" ref-type="bibr">13</xref>]</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">O(<italic>n</italic> log (<italic>n</italic>))</td><td align="center" valign="middle" rowspan="1" colspan="1">Bad</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1"><bold>ACR [<xref rid="B7-sensors-17-00858" ref-type="bibr">7</xref>]</bold></td><td align="center" valign="middle" rowspan="1" colspan="1">O(<italic>n</italic>)</td><td align="center" valign="middle" rowspan="1" colspan="1">Fair</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>DPCRA [<xref rid="B11-sensors-17-00858" ref-type="bibr">11</xref>]</bold></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">O(2<italic>n</italic>)</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Worst</td></tr></tbody></table></table-wrap><table-wrap id="sensors-17-00858-t006" orientation="portrait" position="float"><object-id pub-id-type="pii">sensors-17-00858-t006_Table 6</object-id><label>Table 6</label><caption><p>Improvement of EAR in percentile as compared with competing approaches: RNF, DPCRA, ACR, and ACRA.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Parameters</th><th colspan="3" align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1">Improvement in EAR</th></tr></thead><tbody><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Number of alive Days (Scenario-1)</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">0.5&#x02013;11%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Number of alive Days (Scenario-2)</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">7.93&#x02013;20.37%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Number of alive Days (Scenario-3)</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">14.9&#x02013;27.71%</td></tr><tr><td rowspan="2" align="center" valign="middle" style="border-bottom:solid thin" colspan="1"><bold>Residual Energy in J at 9, 18, &#x00026; 27 (Events)</bold></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">9</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">18</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">27</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2&#x02013;15%</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">16&#x02013;29%</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">16&#x02013;33%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Actor Recovery time (Seconds) with 1200 &#x000d7; 1200 m<sup>2</sup> network topology</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">3.19&#x02013;20%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Actor Recovery time (Seconds) with 1400 &#x000d7; 1400 m<sup>2</sup> network topology</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">3.21&#x02013;20.8%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Data Recovery of 15 KB with 10 Events</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">10&#x02013;26%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Data Recovery of 30 KB with 20 Events</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">2.41&#x02013;20.66%</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Execution Time (Seconds)</bold></td><td colspan="3" align="center" valign="middle" style="border-bottom:solid thin" rowspan="1">0.2&#x02013;2.9%</td></tr></tbody></table></table-wrap></floats-group></article>